// Predictive Recursive Descent Parser generated by Solar 1.4.0 (RD mode)

class Parser {
  constructor() {
    this.la = null;        // Current lookahead token
    this.lexer = null;     // Lexer instance
    this.yy = {};          // Shared state
  }

  // Initialize parser with input
  parse(input) {
    this.lexer = this._createLexer();
    this.lexer.setInput(input, this.yy);
    this.la = this._nextToken();
    const result = this.parse#{@start}();
    if (this.la.kind !== '$end') {
      this._error(['$end'], 'Expected end of input');
    }
    return result;
  }

  // Get next token from lexer
  _nextToken() {
    const tok = this.lexer.lex() || '$end';
    const kind = typeof tok === 'number' ? this._tokenName(tok) : tok;
    return {
      kind: kind,
      value: this.lexer.yytext,
      line: this.lexer.yylineno,
      column: this.lexer.yylloc?.first_column || 0
    };
  }

  // Match expected token and advance
  _match(kind) {
    if (this.la.kind !== kind) {
      this._error([kind], `Expected ${kind}`);
    }
    const tok = this.la;
    this.la = this._nextToken();
    return tok;
  }

  // Check if current token is in set
  _check(...kinds) {
    return kinds.includes(this.la.kind);
  }

  // Error handling
  _error(expected, msg) {
    const line = this.la.line + 1;
    const col = this.la.column;
    const token = this.la.kind;
    throw new Error(
      `Parse error at line ${line}, column ${col}: ${msg}\n` +
      `Got '${token}', expected one of: ${expected.join(', ')}`
    );
  }

  // Token name lookup
  _tokenName(id) {
    const names = {"2":"error","7":"EOL","10":"COMMENT","13":"LABEL","24":"LPAREN","26":"RPAREN","27":"IDENTIFIER","29":"COMMA","30":"SPACE","31":"SPACES","32":"TAB","33":"DOT_LEVEL","34":"DOT","41":"BREAK","45":"CLOSE","47":"DO","49":"ELSE","51":"FOR","53":"GOTO","55":"HALT","57":"HANG","59":"IF","61":"JOB","63":"KILL","65":"LOCK","67":"MERGE","69":"NEW","71":"OPEN","73":"QUIT","75":"READ","77":"SET","79":"TCOMMIT","81":"TSTART","83":"USE","85":"VIEW","87":"WRITE","89":"XECUTE","91":"POSTCOND_START","96":"COLON","104":"INDIRECTION","106":"EQUALS","135":"PLUS","136":"MINUS","150":"MULTIPLY","151":"MODULO","152":"OR","163":"INTRINSIC","176":"PATTERN_MATCH","183":"AND","185":"LESS","186":"GREATER","187":"CONTAINS","188":"FOLLOWS","189":"SORTS_AFTER","190":"NOT_COMPARE","192":"NOT_PATTERN_MATCH","193":"PATTERN_INDIRECT","194":"NOT_PATTERN_INDIRECT","196":"CONCAT","199":"DIVIDE","200":"INT_DIVIDE","202":"POWER","203":"NOT","209":"INTEGER","210":"REAL","211":"STRING","214":"GLOBAL_PREFIX","215":"NAKED_GLOBAL","216":"PIPE","220":"TEXT","222":"EXTRINSIC","229":"ZDIGITS"};
    return names[id] || id;
}

// Create lexer (stub - override with actual lexer)
_createLexer() {
  if (this.lexer) return this.lexer;
  throw new Error('No lexer provided. Set parser.lexer before calling parse()');
}

// ========================================================================
// Parse Functions (one per nonterminal)
// ========================================================================

    }

const parser = new Parser();

export { parser, Parser };
export const parse = parser.parse.bind(parser);
export default parser;