# ==============================================================================
# Solar Syntax - S-Expression Grammar for Rip
# ==============================================================================
#
# This is an LL(1)-friendly version of the Rip grammar with:
# - List patterns transformed to use *Tail helpers
# - Clear separation of concerns
# - Generator-friendly structure
# - Preserved semantic meaning (same AST output)
#
# Note: Some rules (ObjSpreadExpr, SimpleAssignable, Operation) intentionally
# keep left recursion - see comments for generator handling strategies.
#

o = (pattern, action, options) ->
  pattern = pattern.trim().replace /\s{2,}/g, ' '
  [pattern, action ? 1, options]

mode = 'sexp'

grammar =

  # The **Root** is the top-level node in the syntax tree. All parsing ends here.
  Root: [
    o ''    , '["program"]'
    o 'Body', '["program", ...1]'
  ]

  # Any list of statements and expressions, separated by line breaks or semicolons.
  # FIXED: Removed left recursion - now uses BodyTail helper
  Body: [
    o 'Line BodyTail', '[1, ...2]'
  ]

  # Tail helper for Body - builds list right-recursively
  BodyTail: [
    o 'TERMINATOR Line BodyTail', '[2, ...3]'
    o 'TERMINATOR BodyTail'     , '[...2]'
    o ''                        , '[]'
  ]

  # Line is just a pass-through (default action returns the first token)
  Line: [
    o 'Expression'
    o 'ExpressionLine'
    o 'Statement'
  ]

  # Pure statements which cannot be expressions.
  Statement: [
    o 'Return'
    o 'STATEMENT'  # Statements like break, continue, debugger
    o 'Import'
    o 'Export'
  ]

  # All the different types of expressions in our language. The basic unit of
  # CoffeeScript is the **Expression** -- everything that can be an expression
  # is one. Blocks serve as the building blocks of many other rules, making
  # them somewhat circular.
  # NOTE: Dispatch order matters - specific types first, Operation handles assignments too
  Expression: [
    o 'If'         # Control flow (IF, UNLESS tokens)
    o 'For'        # For loops (FOR token)
    o 'While'      # While loops (WHILE, UNTIL, LOOP tokens)
    o 'Try'        # Try/catch (TRY token)
    o 'Switch'     # Switch statements (SWITCH token)
    o 'Def'        # Function definitions (DEF token)
    o 'Class'      # Class definitions (CLASS token)
    o 'Code'       # Arrow functions (PARAM_START, ->, =>)
    o 'Yield'      # Generator yield (YIELD token)
    o 'Throw'      # Throw statements (THROW token)
    o 'Operation'  # Values + operators + assignments (handles everything else)
  ]

  # Primary expressions - base expressions without operations or control flow
  # Used by Operation to prevent Expression ↔ Operation cycles
  # Operation → PrimaryExpression OP PrimaryExpression (no cycle!)
  # NOTE: Just dispatch to Operation since it handles all base cases + operators!
  PrimaryExpression: [
    o 'Operation'      # Operation handles Value, Code, operators, etc.
  ]

  # Def functions (Rip-specific syntax)
  Def: [
    o 'DEF Identifier CALL_START ParamList CALL_END Block', '["def", 2, 4, 6]'
    o 'DEF Identifier Block'                              , '["def", 2, [], 3]'  # No params
  ]

  # Expressions which are written in single line and would otherwise require being
  # wrapped in braces: E.g `a = b if do -> f a is 1`, `if f (a) -> a*2 then ...`,
  # `for x in do (obj) -> f obj when x > 8 then f x`
  ExpressionLine: [
    o 'CodeLine'
    o 'OperationLine'
  ]

  # Yield expressions (for generators)
  Yield: [
    o 'YIELD'                      , '["yield"]'
    o 'YIELD Expression'           , '["yield", 2]'
    o 'YIELD INDENT Object OUTDENT', '["yield", 3]'
    o 'YIELD FROM Expression'      , '["yield-from", 3]'
  ]

  # An indented block of expressions. Note that the rewriter
  # will convert some postfix forms into blocks for us, by adjusting the
  # token stream.
  Block: [
    o 'INDENT OUTDENT'     , '["block"]'
    o 'INDENT Body OUTDENT', '["block", ...2]'
  ]

  # Identifier - just return the token value (e.g., "console", "x")
  Identifier: [
    o 'IDENTIFIER'
  ]

  # Property - return the property name (e.g., "log", "name")
  Property: [
    o 'PROPERTY'
  ]

  # Alphanumerics - numbers and strings (pass through)
  AlphaNumeric: [
    o 'NUMBER'
    o 'String'
  ]

  # String literals
  String: [
    o 'STRING'
    o 'STRING_START Interpolations STRING_END', '["str", ...2]'
  ]

  # Interpolations accumulate parts of template strings
  # FIXED: Removed left recursion - now uses InterpolationsTail
  Interpolations: [
    o 'InterpolationChunk InterpolationsTail', '[1, ...2]'
  ]

  # Tail helper for Interpolations
  InterpolationsTail: [
    o 'InterpolationChunk InterpolationsTail', '[1, ...2]'
    o ''                                     , '[]'
  ]

  # Each chunk is either a string part or an interpolated expression
  InterpolationChunk: [
    o 'INTERPOLATION_START Body INTERPOLATION_END'               , 2
    o 'INTERPOLATION_START INDENT Body OUTDENT INTERPOLATION_END', 3
    o 'INTERPOLATION_START INTERPOLATION_END'                    , '""'
    o 'String'
  ]

  # Regular expressions
  Regex: [
    o 'REGEX'  # Pass through regex literal
    o 'REGEX_START Invocation REGEX_END', '["regex", 2]'
  ]

  # Regex with optional capture index (for regex indexing feature)
  RegexWithIndex: [
    o 'Regex , Expression', '["regex-index", 1, 3]'     # x[/pattern/, n] - with capture
    o 'Regex'             , '["regex-index", 1, null]'  # x[/pattern/] - no capture
  ]

  # All immediate values - numbers, strings, booleans, etc.
  Literal: [
    o 'AlphaNumeric'
    o 'JS'        # Embedded JavaScript (backticks)
    o 'Regex'
    o 'UNDEFINED' , '"undefined"'
    o 'NULL'      , '"null"'
    o 'BOOL'      # true/false pass through
    o 'INFINITY'  # Infinity passes through
    o 'NAN'       # NaN passes through
  ]

  # Assignment: variable = value
  Assign: [
    o 'Assignable = Expression'               , '["=", 1, 3]'
    o 'Assignable = TERMINATOR Expression'    , '["=", 1, 4]'
    o 'Assignable = INDENT Expression OUTDENT', '["=", 1, 4]'
  ]

  # Assignment when it happens within an object literal. The difference from
  # the ordinary **Assign** is that these allow numbers and strings as keys.
  # Returns [key, value] pairs for building object literals
  AssignObj: [
    o 'ObjAssignable'                                  , '[1, 1, null]'  # Property shorthand: {x} → [x, x, null]
    o 'ObjRestValue'                                                     # Rest properties: {...rest}
    o 'ObjAssignable : Expression'                     , '[1, 3, ":"]'   # Property: {a: 5}
    o 'ObjAssignable : INDENT Expression OUTDENT'      , '[1, 4, ":"]'   # Property (indented)
    o 'SimpleObjAssignable = Expression'               , '[1, 3, "="]'   # Default: {a = 5}
    o 'SimpleObjAssignable = INDENT Expression OUTDENT', '[1, 4, "="]'   # Default (indented)
  ]

  SimpleObjAssignable: [
    o 'Identifier'
    o 'Property'
    o 'ThisProperty'
  ]

  ObjAssignable: [
    o 'SimpleObjAssignable'
    o '[ Expression ]'  , '["computed", 2]'  # Computed property name
    o '@ [ Expression ]', '["[]", "this", 3]'
    o 'AlphaNumeric'
  ]

  # Object literal spread/rest properties - ES6 prefix only
  ObjRestValue: [
    o '... SimpleObjAssignable', '["...", 2]'  # ES6: {...rest}
    o '... ObjSpreadExpr'      , '["...", 2]'  # ES6: {...obj}
  ]

  # Object spread expressions with accessors
  # NOTE: This rule has 10 left-recursive productions for accessor chains.
  # Generator should handle with iterative loop:
  #   base = parseBase()
  #   while (accessor_token) { base = buildAccessor(base, accessor) }
  # This creates chains like: obj.foo.bar[0]?.baz
  ObjSpreadExpr: [
    # Base cases
    o 'SimpleObjAssignable'
    o 'Object'
    o 'Parenthetical'
    o 'Super'
    o 'This'
    o 'SUPER OptFuncExist Arguments'              , '["super", ...3]'
    o 'DYNAMIC_IMPORT Arguments'                  , '["import", ...2]'
    o 'SimpleObjAssignable OptFuncExist Arguments', '[1, ...3]'
    o 'ObjSpreadExpr OptFuncExist Arguments'      , '[1, ...3]'
    # Recursive accessors (LEFT-RECURSIVE - generator handles)
    o 'ObjSpreadExpr . Property'                  , '[".", 1, 3]'
    o 'ObjSpreadExpr ?. Property'                 , '["?.", 1, 3]'
    o 'ObjSpreadExpr :: Property'                 , '["::", 1, 3]'
    o 'ObjSpreadExpr ?:: Property'                , '["?::", 1, 3]'
    o 'ObjSpreadExpr ::'                          , '["::", 1, "prototype"]'
    o 'ObjSpreadExpr ?::'                         , '["?::", 1, "prototype"]'
    o 'ObjSpreadExpr INDEX_START Expression INDEX_END'                          , '["[]", 1, 3]'
    o 'ObjSpreadExpr INDEX_START INDENT Expression OUTDENT INDEX_END'           , '["[]", 1, 4]'
    o 'ObjSpreadExpr INDEX_SOAK INDEX_START Expression INDEX_END'               , '["?[]", 1, 4]'
    o 'ObjSpreadExpr INDEX_SOAK INDEX_START INDENT Expression OUTDENT INDEX_END', '["?[]", 1, 5]'
  ]

  # Return statement
  Return: [
    o 'RETURN Expression'           , '["return", 2]'
    o 'RETURN INDENT Object OUTDENT', '["return", 3]'
    o 'RETURN'                      , '["return"]'
  ]

  # Arrow functions: (params) -> body or (params) => body
  Code: [
    o 'PARAM_START ParamList PARAM_END FuncGlyph Block', '[4, 2, 5]'  # [arrow, params, body]
    o 'FuncGlyph Block'                                , '[1, [], 2]'
  ]

  # Single-line arrow functions
  CodeLine: [
    o 'PARAM_START ParamList PARAM_END FuncGlyph Line', '[4, 2, 5]'
    o 'FuncGlyph Line'                                , '[1, [], 2]'
  ]

  # Function arrow type: -> or =>
  FuncGlyph: [
    o '->'
    o '=>'
  ]

  # An optional, trailing comma.
  OptComma: [
    o ''
    o ','
  ]

  # Parameter list accumulation
  # FIXED: Removed left recursion - now uses ParamListTail helper
  ParamList: [
    o ''                                  , '[]'
    o 'Param ParamListTail'               , '[1, ...2]'
    o 'INDENT ParamList OptComma OUTDENT' , 2
  ]

  # Tail helper for ParamList
  ParamListTail: [
    o ', Param ParamListTail'                       , '[2, ...3]'
    o 'OptComma TERMINATOR Param ParamListTail'     , '[3, ...4]'
    o 'OptComma INDENT ParamList OptComma OUTDENT'  , '[...3]'
    o ''                                            , '[]'
  ]

  # Individual parameters (can be identifier, destructuring, rest, or default)
  Param: [
    o 'ParamVar'  # Simple param
    o '... ParamVar'         , '["rest", 2]'        # ES6 prefix rest only: ...name
    o 'ParamVar = Expression', '["default", 1, 3]'  # Default param
    o '...'                  , '["expansion"]'      # Expansion
  ]

  # Function Parameters
  ParamVar: [
    o 'Identifier'
    o 'ThisProperty'
    o 'Array'   # Array destructuring
    o 'Object'  # Object destructuring
  ]

  # Spread operator (in calls and arrays) - ES6 prefix only
  Splat: [
    o '... Expression', '["...", 2]'  # ES6 prefix: ...expr
  ]

  # SimpleAssignable: things that can be assigned to
  # NOTE: This rule has many left-recursive accessor patterns.
  # Generator should handle similarly to ObjSpreadExpr with iterative loop.
  # The accessor patterns create chains: value.prop[index]?.other
  SimpleAssignable: [
    o 'Identifier'
    o 'ThisProperty'
    # Value with property access (LEFT-RECURSIVE - generator handles)
    o 'Value . Property'  , '[".", 1, 3]'
    o 'Value ?. Property' , '["?.", 1, 3]'
    o 'Value :: Property' , '["::", 1, 3]'
    o 'Value ?:: Property', '["?::", 1, 3]'
    o 'Value ::'          , '["::", 1, "prototype"]'
    o 'Value ?::'         , '["?::", 1, "prototype"]'
    # Regular indexing
    o 'Value INDEX_START Expression INDEX_END'                                  , '["[]", 1, 3]'
    o 'Value INDEX_START INDENT Expression OUTDENT INDEX_END'                   , '["[]", 1, 4]'
    o 'Value INDEX_START Slice INDEX_END'                                       , '["[]", 1, 3]'
    o 'Value INDEX_START INDENT Slice OUTDENT INDEX_END'                        , '["[]", 1, 4]'
    # Regex indexing with capture group
    o 'Value INDEX_START RegexWithIndex INDEX_END'                              , '[$3[0], $1, ...$3.slice(1)]'
    # CoffeeScript soak indexing (?[)
    o 'Value INDEX_SOAK INDEX_START Expression INDEX_END'                       , '["?[]", 1, 4]'
    o 'Value INDEX_SOAK INDEX_START INDENT Expression OUTDENT INDEX_END'        , '["?[]", 1, 5]'
    o 'Value INDEX_SOAK INDEX_START Slice INDEX_END'                            , '["?[]", 1, 4]'
    o 'Value INDEX_SOAK INDEX_START INDENT Slice OUTDENT INDEX_END'             , '["?[]", 1, 5]'
    # ES6 optional indexing (?.[)
    o 'Value ES6_OPTIONAL_INDEX INDEX_START Expression INDEX_END'               , '["optindex", 1, 4]'
    o 'Value ES6_OPTIONAL_INDEX INDEX_START INDENT Expression OUTDENT INDEX_END', '["optindex", 1, 5]'
    # Code (arrow function) with accessor
    o 'Code . Property'                                                         , '[".", 1, 3]'
    o 'Code ?. Property'                                                        , '["?.", 1, 3]'
    o 'Code :: Property'                                                        , '["::", 1, 3]'
    o 'Code ?:: Property'                                                       , '["?::", 1, 3]'
    o 'Code ::'                                                                 , '["::", 1, "prototype"]'
    o 'Code ?::'                                                                , '["?::", 1, "prototype"]'
    o 'Code INDEX_START Expression INDEX_END'                                   , '["[]", 1, 3]'
    o 'Code INDEX_START INDENT Expression OUTDENT INDEX_END'                    , '["[]", 1, 4]'
    o 'Code INDEX_SOAK INDEX_START Expression INDEX_END'                        , '["?[]", 1, 4]'
    o 'Code INDEX_SOAK INDEX_START INDENT Expression OUTDENT INDEX_END'         , '["?[]", 1, 5]'
  ]

  # Assignable: can be identifier, array pattern, or object pattern
  Assignable: [
    o 'SimpleAssignable'
    o 'Array'   # Array destructuring pattern
    o 'Object'  # Object destructuring pattern
  ]

  # Value: expressions that produce values (all pass through)
  Value: [
    o 'Assignable'
    o 'Literal'
    o 'Parenthetical'
    o 'Range'
    o 'Invocation'
    o 'DoIife'
    o 'This'
    o 'Super'
    o 'MetaProperty'
  ]

  # Super property access and calls
  Super: [
    o 'SUPER . Property'                                     , '[".", "super", 3]'
    o 'SUPER INDEX_START Expression INDEX_END'               , '["[]", "super", 3]'
    o 'SUPER INDEX_START INDENT Expression OUTDENT INDEX_END', '["[]", "super", 4]'
  ]

  # Meta-properties: new.target or import.meta
  MetaProperty: [
    o 'NEW_TARGET . Property' , '[".", "new", 3]'
    o 'IMPORT_META . Property', '[".", "import", 3]'
  ]

  # Object literals
  Object: [
    # Object comprehensions - must come before regular objects
    o '{ ObjAssignable : Expression FOR ForVariables FOROF Expression OptComma }'                    , '["object-comprehension", 2, 4, [["for-of", 6, 8, false]], []]'
    o '{ ObjAssignable : Expression FOR ForVariables FOROF Expression WHEN Expression OptComma }'    , '["object-comprehension", 2, 4, [["for-of", 6, 8, false]], [10]]'
    o '{ ObjAssignable : Expression FOR OWN ForVariables FOROF Expression OptComma }'                , '["object-comprehension", 2, 4, [["for-of", 7, 9, true]], []]'
    o '{ ObjAssignable : Expression FOR OWN ForVariables FOROF Expression WHEN Expression OptComma }', '["object-comprehension", 2, 4, [["for-of", 7, 9, true]], [11]]'
    # Regular object literals
    o '{ AssignList OptComma }', '["object", ...2]'
  ]

  # Object property list accumulation
  # FIXED: Removed left recursion - now uses AssignListTail helper
  AssignList: [
    o ''                                  , '[]'
    o 'AssignObj AssignListTail'          , '[1, ...2]'
    o 'INDENT AssignList OptComma OUTDENT', 2
  ]

  # Tail helper for AssignList
  AssignListTail: [
    o ', AssignObj AssignListTail'                      , '[2, ...3]'
    o 'OptComma TERMINATOR AssignObj AssignListTail'    , '[3, ...4]'
    o 'OptComma INDENT AssignList OptComma OUTDENT'     , '[...3]'
    o ''                                                , '[]'
  ]

  # Class definitions
  Class: [
    o 'CLASS'                                          , '["class", null, null]'
    o 'CLASS Block'                                    , '["class", null, null, 2]'
    o 'CLASS EXTENDS Expression'                       , '["class", null, 3]'
    o 'CLASS EXTENDS Expression Block'                 , '["class", null, 3, 4]'
    o 'CLASS SimpleAssignable'                         , '["class", 2, null]'
    o 'CLASS SimpleAssignable Block'                   , '["class", 2, null, 3]'
    o 'CLASS SimpleAssignable EXTENDS Expression'      , '["class", 2, 4]'
    o 'CLASS SimpleAssignable EXTENDS Expression Block', '["class", 2, 4, 5]'
  ]

  # Import statements - simplified for Rip
  Import: [
    o 'IMPORT String'                                                               , '["import", "{}", 2]'
    o 'IMPORT ImportDefaultSpecifier FROM String'                                   , '["import", 2, 4]'
    o 'IMPORT ImportNamespaceSpecifier FROM String'                                 , '["import", 2, 4]'
    o 'IMPORT { } FROM String'                                                      , '["import", "{}", 5]'
    o 'IMPORT { ImportSpecifierList OptComma } FROM String'                         , '["import", 3, 7]'
    o 'IMPORT ImportDefaultSpecifier , ImportNamespaceSpecifier FROM String'        , '["import", [2, 4], 6]'
    o 'IMPORT ImportDefaultSpecifier , { ImportSpecifierList OptComma } FROM String', '["import", [2, 5], 9]'
  ]

  # FIXED: Removed left recursion from ImportSpecifierList
  ImportSpecifierList: [
    o 'ImportSpecifier ImportSpecifierListTail'      , '[1, ...2]'
    o 'INDENT ImportSpecifierList OptComma OUTDENT'  , 2
  ]

  # Tail helper for ImportSpecifierList
  ImportSpecifierListTail: [
    o ', ImportSpecifier ImportSpecifierListTail'                               , '[2, ...3]'
    o 'OptComma TERMINATOR ImportSpecifier ImportSpecifierListTail'             , '[3, ...4]'
    o 'OptComma INDENT ImportSpecifierList OptComma OUTDENT'                    , '[...3]'
    o ''                                                                        , '[]'
  ]

  ImportSpecifier: [
    o 'Identifier'                           # Simple import
    o 'Identifier AS Identifier' , '[1, 3]'  # Aliased import
    o 'DEFAULT'                              # Default import
    o 'DEFAULT AS Identifier'    , '[1, 3]'  # Aliased default
  ]

  ImportDefaultSpecifier: [
    o 'Identifier'
  ]

  ImportNamespaceSpecifier: [
    o 'IMPORT_ALL AS Identifier', '["*", 3]'
  ]

  # Export statements
  Export: [
    o 'EXPORT { }'                                         , '["export", "{}"]'
    o 'EXPORT { ExportSpecifierList OptComma }'            , '["export", 3]'
    o 'EXPORT Class'                                       , '["export", 2]'
    o 'EXPORT Def'                                         , '["export", 2]'
    o 'EXPORT Identifier = Expression'                     , '["export", ["=", 2, 4]]'
    o 'EXPORT Identifier = TERMINATOR Expression'          , '["export", ["=", 2, 5]]'
    o 'EXPORT Identifier = INDENT Expression OUTDENT'      , '["export", ["=", 2, 5]]'
    o 'EXPORT DEFAULT Expression'                          , '["export-default", 3]'
    o 'EXPORT DEFAULT INDENT Object OUTDENT'               , '["export-default", 4]'
    o 'EXPORT EXPORT_ALL FROM String'                      , '["export-all", 4]'
    o 'EXPORT { } FROM String'                             , '["export-from", "{}", 5]'
    o 'EXPORT { ExportSpecifierList OptComma } FROM String', '["export-from", 3, 7]'
  ]

  # FIXED: Removed left recursion from ExportSpecifierList
  ExportSpecifierList: [
    o 'ExportSpecifier ExportSpecifierListTail'      , '[1, ...2]'
    o 'INDENT ExportSpecifierList OptComma OUTDENT'  , 2
  ]

  # Tail helper for ExportSpecifierList
  ExportSpecifierListTail: [
    o ', ExportSpecifier ExportSpecifierListTail'                               , '[2, ...3]'
    o 'OptComma TERMINATOR ExportSpecifier ExportSpecifierListTail'             , '[3, ...4]'
    o 'OptComma INDENT ExportSpecifierList OptComma OUTDENT'                    , '[...3]'
    o ''                                                                        , '[]'
  ]

  ExportSpecifier: [
    o 'Identifier'                          # Simple export
    o 'Identifier AS Identifier', '[1, 3]'  # Aliased export
    o 'Identifier AS DEFAULT'   , '[1, 3]'  # Export as default
    o 'DEFAULT'                             # Export default keyword
    o 'DEFAULT AS Identifier'   , '[1, 3]'
  ]

  # Function calls and invocations
  # NOTE: Using Assignable instead of Value to prevent Value ↔ Invocation cycles
  Invocation: [
    o 'Assignable OptFuncExist String'        , '["tagged-template", 1, 3]'               # Tagged template literal
    o 'Assignable OptFuncExist Arguments'     , '2 ? ["?call", 1, ...3] : [1, ...3]'      # Regular/soak call
    o 'Assignable ES6_OPTIONAL_CALL Arguments', '["optcall", 1, ...3]'                    # ES6 optional call
    o 'SUPER OptFuncExist Arguments'     , '2 ? ["?super", ...3] : ["super", ...3]'  # Super call
    o 'DYNAMIC_IMPORT Arguments'         , '["import", ...2]'                        # Dynamic import
  ]

  # Optional existence check (? operator for function calls)
  OptFuncExist: [
    o ''           , 'null'  # No soak
    o 'FUNC_EXIST' , 'true'  # Has soak - mark as soak call
  ]

  # Function arguments
  Arguments: [
    o 'CALL_START CALL_END'                 , '[]'
    o 'CALL_START ArgList OptComma CALL_END', 2
  ]

  # Reference to 'this'
  This: [
    o 'THIS', '"this"'
    o '@'   , '"this"'
  ]

  # Reference to this.property
  ThisProperty: [
    o '@ Property', '[".", "this", 2]'
  ]

  # Array literals
  Array: [
    o '[ ]'                           , '["array"]'
    o '[ Elisions ]'                  , '["array", ...2]'
    o '[ ArgElisionList OptElisions ]', '["array", ...2, ...3]'
  ]

  # Range operators
  RangeDots: [
    o '..'  , '".."'   # Inclusive
    o '...', '"..."'  # Exclusive
  ]

  # Range literals (CoffeeScript-style in arrays)
  Range: [
    o '[ Expression RangeDots Expression ]', '[3, 2, 4]'  # [from..to]
  ]

  # Array slices
  Slice: [
    o 'Expression RangeDots Expression', '[2, 1, 3]'     # expr..expr
    o 'Expression RangeDots'           , '[2, 1, null]'  # expr..
    o 'RangeDots Expression'           , '[1, null, 2]'  # ..expr
    o 'RangeDots'                      , '[1, null, null]'  # ..
  ]

  # Argument list for function calls
  # FIXED: Removed left recursion - now uses ArgListTail helper
  ArgList: [
    o 'Arg ArgListTail'                 , '[1, ...2]'
    o 'INDENT ArgList OptComma OUTDENT' , 2
  ]

  # Tail helper for ArgList
  ArgListTail: [
    o ', Arg ArgListTail'                           , '[2, ...3]'
    o 'OptComma TERMINATOR Arg ArgListTail'         , '[3, ...4]'
    o 'OptComma INDENT ArgList OptComma OUTDENT'    , '[...3]'
    o ''                                            , '[]'
  ]

  # Individual argument
  Arg: [
    o 'Expression'
    o 'ExpressionLine'
    o 'Splat'
    o '...', '"..."'  # Expansion marker
  ]

  # Array elision lists (for sparse arrays with holes)
  # FIXED: Removed left recursion - now uses ArgElisionListTail helper
  ArgElisionList: [
    o 'ArgElision ArgElisionListTail'                  , '[...1, ...2]'
    o 'INDENT ArgElisionList OptElisions OUTDENT'      , '[...2, ...3]'
  ]

  # Tail helper for ArgElisionList
  ArgElisionListTail: [
    o ', ArgElision ArgElisionListTail'                                    , '[...2, ...3]'
    o 'OptComma TERMINATOR ArgElision ArgElisionListTail'                  , '[...3, ...4]'
    o 'OptElisions INDENT ArgElisionList OptElisions OUTDENT'              , '[...1, ...3, ...4]'
    o ''                                                                   , '[]'
  ]

  ArgElision: [
    o 'Arg'         , '[1]'
    o 'Elisions Arg', '[...1, 2]'
  ]

  OptElisions: [
    o 'OptComma'  , '[]'
    o ', Elisions', '[...2]'
  ]

  # FIXED: Removed left recursion from Elisions
  Elisions: [
    o 'Elision ElisionsTail', '[1, ...2]'
  ]

  # Tail helper for Elisions
  ElisionsTail: [
    o 'Elision ElisionsTail', '[1, ...2]'
    o ''                    , '[]'
  ]

  Elision: [
    o ','                 , 'null'  # Hole in array
    o 'Elision TERMINATOR'
  ]

  # Simple argument lists for switch statements
  # FIXED: Removed left recursion - now uses SimpleArgsTail helper
  SimpleArgs: [
    o 'Expression SimpleArgsTail', 'Array.isArray($2) && $2.length > 0 ? [$1, ...$2] : [$1]'
  ]

  # Tail helper for SimpleArgs
  SimpleArgsTail: [
    o ', Expression SimpleArgsTail', '[$2, ...$3]'
    o ''                           , '[]'
  ]

  # Try/catch/finally exception handling
  Try: [
    o 'TRY Block'                    , '["try", 2]'
    o 'TRY Block Catch'              , '["try", 2, 3]'     # Will expand Catch
    o 'TRY Block FINALLY Block'      , '["try", 2, 4]'
    o 'TRY Block Catch FINALLY Block', '["try", 2, 3, 5]'  # Will expand Catch
  ]

  # Catch clause
  Catch: [
    o 'CATCH Identifier Block', '[2, 3]'     # [param, block]
    o 'CATCH Object Block'    , '[2, 3]'     # [pattern, block]
    o 'CATCH Block'           , '[null, 2]'  # [null, block] - no param
  ]

  # Throw statement
  Throw: [
    o 'THROW Expression'           , '["throw", 2]'
    o 'THROW INDENT Object OUTDENT', '["throw", 3]'
  ]

  # Parenthesized expressions - unwrap single-element Bodies
  Parenthetical: [
    o '( Body )'               , '$2.length === 1 ? $2[0] : $2'
    o '( INDENT Body OUTDENT )', '$3.length === 1 ? $3[0] : $3'
  ]

  # While loop conditions (consolidated)
  WhileSource: [
    o 'WHILE PrimaryExpression'                , '["while", 2]'
    o 'WHILE PrimaryExpression WHEN PrimaryExpression', '["while", 2, 4]'
    o 'UNTIL PrimaryExpression'                , '["until", 2]'
    o 'UNTIL PrimaryExpression WHEN PrimaryExpression', '["until", 2, 4]'
  ]

  # While loops - combine source + block
  # Note: Postfix forms removed to avoid Expression cycles
  While: [
    o 'WhileSource Block'      , '$1.length === 2 ? [$1[0], $1[1], $2]   : [$1[0], $1[1], $1[2], $2]'
    o 'Loop'
  ]

  # Infinite loop
  Loop: [
    o 'LOOP Block'     , '["loop", 2]'
    o 'LOOP Expression', '["loop", [2]]'
  ]

  # For loops - build complete s-expressions directly
  # Structure: ["for-in", vars, iterable, step, guard, body]
  # Structure: ["for-of", vars, object, guard, body]
  # NOTE: Not transformed - would require complex factoring. These are already
  # well-structured with the precedence table handling disambiguation.
  For: [
    # Block form (prefix - FOR comes first)
    o 'FOR ForVariables FORIN Expression Block'                              , '["for-in"  , 2, 4, null, null, 5]'
    o 'FOR ForVariables FORIN Expression WHEN Expression Block'              , '["for-in"  , 2, 4, null, 6, 7]'
    o 'FOR ForVariables FORIN Expression BY Expression Block'                , '["for-in"  , 2, 4, 6, null, 7]'
    o 'FOR ForVariables FORIN Expression WHEN Expression BY Expression Block', '["for-in"  , 2, 4, 8, 6, 9]'
    o 'FOR ForVariables FORIN Expression BY Expression WHEN Expression Block', '["for-in"  , 2, 4, 6, 8, 9]'
    o 'FOR ForVariables FOROF Expression Block'                              , '["for-of"  , 2, 4, false, null, 5]'
    o 'FOR ForVariables FOROF Expression WHEN Expression Block'              , '["for-of"  , 2, 4, false, 6, 7]'
    o 'FOR OWN ForVariables FOROF Expression Block'                          , '["for-of"  , 3, 5, true, null, 6]'
    o 'FOR OWN ForVariables FOROF Expression WHEN Expression Block'          , '["for-of"  , 3, 5, true, 7, 8]'
    o 'FOR ForVariables FORFROM Expression Block'                            , '["for-from", 2, 4, false, null, 5]'
    o 'FOR ForVariables FORFROM Expression WHEN Expression Block'            , '["for-from", 2, 4, false, 6, 7]'
    o 'FOR AWAIT ForVariables FORFROM Expression Block'                      , '["for-from", 3, 5, true, null, 6]'
    o 'FOR AWAIT ForVariables FORFROM Expression WHEN Expression Block'      , '["for-from", 3, 5, true, 7, 8]'
    o 'FOR Range Block'                                                      , '["for-in"  , [], 2, null, null, 3]'
    o 'FOR Range BY Expression Block'                                        , '["for-in"  , [], 2, 4, null, 5]'

    # Postfix form / Comprehensions (expression comes BEFORE for)
    # Note: Removed for LL(1) - these create Expression → For → Expression cycles
    # Can be re-added with special handling for comprehensions later
    # o 'Expression FOR ForVariables FORIN Expression'                               , '["comprehension", 1, [["for-in"  , 3, 5, null]], []]'
    # o 'Expression FOR ForVariables FORIN Expression WHEN Expression'               , '["comprehension", 1, [["for-in"  , 3, 5, null]], [7]]'
    # o 'Expression FOR ForVariables FORIN Expression BY Expression'                 , '["comprehension", 1, [["for-in"  , 3, 5, 7]], []]'
    # o 'Expression FOR ForVariables FORIN Expression WHEN Expression BY Expression' , '["comprehension", 1, [["for-in"  , 3, 5, 9]], [7]]'
    # o 'Expression FOR ForVariables FORIN Expression BY Expression WHEN Expression' , '["comprehension", 1, [["for-in"  , 3, 5, 7]], [9]]'
    # o 'Expression FOR ForVariables FOROF Expression'                               , '["comprehension", 1, [["for-of"  , 3, 5, false]], []]'
    # o 'Expression FOR ForVariables FOROF Expression WHEN Expression'               , '["comprehension", 1, [["for-of"  , 3, 5, false]], [7]]'
    # o 'Expression FOR OWN ForVariables FOROF Expression'                           , '["comprehension", 1, [["for-of"  , 4, 6, true]], []]'
    # o 'Expression FOR OWN ForVariables FOROF Expression WHEN Expression'           , '["comprehension", 1, [["for-of"  , 4, 6, true]], [8]]'
    # o 'Expression FOR ForVariables FORFROM Expression'                             , '["comprehension", 1, [["for-from", 3, 5, false, null]], []]'
    # o 'Expression FOR ForVariables FORFROM Expression WHEN Expression'             , '["comprehension", 1, [["for-from", 3, 5, false, null]], [7]]'
    # o 'Expression FOR AWAIT ForVariables FORFROM Expression'                       , '["comprehension", 1, [["for-from", 4, 6, true, null]], []]'
    # o 'Expression FOR AWAIT ForVariables FORFROM Expression WHEN Expression'       , '["comprehension", 1, [["for-from", 4, 6, true, null]], [8]]'
    # # Postfix range (without loop variable) - for N-time repetition
    # o 'Expression FOR Range'                                                       , '["comprehension", 1, [["for-in", [], 3, null]], []]'
    # o 'Expression FOR Range BY Expression'                                         , '["comprehension", 1, [["for-in", [], 3, 5]], []]'
  ]

  ForValue: [
    o 'ForVar'                    # Simple variable
    o 'ForVar = Expression', '["default", 1, 3]'  # With default value (like params)
  ]

  ForVar: [
    o 'Identifier'
    o 'ThisProperty'
    o 'Array'   # Array destructuring
    o 'Object'  # Object destructuring
  ]

  ForVariables: [
    o 'ForValue'           , '[1]'
    o 'ForValue , ForValue', '[1, 3]'
  ]

  # Switch statements
  Switch: [
    o 'SWITCH Expression INDENT Whens OUTDENT'            , '["switch", 2, 4, null]'
    o 'SWITCH Expression INDENT Whens ELSE Block OUTDENT' , '["switch", 2, 4, 6]'
    o 'SWITCH INDENT Whens OUTDENT'                       , '["switch", null, 3, null]'
    o 'SWITCH INDENT Whens ELSE Block OUTDENT'            , '["switch", null, 3, 5]'
  ]

  # When clauses for switch (accumulate into array)
  # FIXED: Removed left recursion - now uses WhensTail helper
  Whens: [
    o 'When WhensTail', '[1, ...2]'
  ]

  # Tail helper for Whens
  WhensTail: [
    o 'When WhensTail', '[1, ...2]'
    o ''              , '[]'
  ]

  # Individual when clause
  When: [
    o 'LEADING_WHEN SimpleArgs Block'           , '["when", 2, 3]'
    o 'LEADING_WHEN SimpleArgs Block TERMINATOR', '["when", 2, 3]'
  ]

  # If statements - combine condition, then, and else branches
  # Use Operation for conditions (Operation handles Value + operators)
  IfBlock: [
    o 'IF Operation Block'              , '["if", 2, 3]'
    o 'IfBlock ELSE IF Operation Block' , '$1.length === 3 ? ["if", $1[1], $1[2], ["if", $4, $5]] : [...$1, ["if", $4, $5]]'
  ]

  UnlessBlock: [
    o 'UNLESS Operation Block'              , '["unless", 2, 3]'
    o 'UNLESS Operation Block ELSE Block'   , '["if", ["!", 2], 3, 5]'  # unless with else = if not
  ]

  # Prefix If/Unless (no cycles)
  If: [
    o 'IfBlock'
    o 'IfBlock ELSE Block'                , '$1.length === 3 ? ["if", $1[1], $1[2], $3] : [...$1, $3]'
    o 'UnlessBlock'
  ]

  # Postfix If/Unless (handled separately to avoid Expression cycles)
  # Note: These cause Expression ↔ PostfixIf cycles, so removed for now
  # Can be added back with special handling if needed
  # PostfixIf: [
  #   o 'Statement POST_IF PrimaryExpression'     , '["if", 3, [1]]'
  #   o 'PrimaryExpression POST_IF PrimaryExpression'    , '["if", 3, [1]]'
  #   o 'Statement POST_UNLESS PrimaryExpression' , '["unless", 3, [1]]'
  #   o 'PrimaryExpression POST_UNLESS PrimaryExpression', '["unless", 3, [1]]'
  # ]

  # Arithmetic and logical operators, working on one or more operands.
  # Here they are grouped by order of precedence. The actual precedence rules
  # are defined at the bottom of the page. It would be shorter if we could
  # combine most of these rules into a single generic *Operand OpSymbol Operand*
  # -type rule, but in order to make the precedence binding possible, separate
  # rules are necessary.
  OperationLine: [
    o 'UNARY ExpressionLine', '[1, 2]'
    o 'DO ExpressionLine'   , '["do-iife", 2]'
    o 'DO_IIFE CodeLine'    , '["do-iife", 2]'
  ]

  # All operations - unary and binary
  # NOTE: Uses Value/Code/etc directly to prevent PrimaryExpression ↔ Operation cycles
  # Also handles simple assignments by checking for = in the while loop
  # The precedence table at the bottom handles disambiguation.
  Operation: [
    # Base case - simple values (no operator)
    o 'Value'
    o 'Code'
    o 'Parenthetical'

    # Unary operators
    o 'UNARY Value'      , '[1, 2]'  # not, typeof, delete, new
    o 'DO Value'         , '["do-iife", 2]'
    o 'UNARY_MATH Value' , '[1, 2]'  # !, ~
    o '- Value'          , '["-", 2]', prec: 'UNARY_MATH'  # Unary minus
    o '+ Value'          , '["+", 2]', prec: 'UNARY_MATH'  # Unary plus

    # Await
    o 'AWAIT Value'            , '["await", 2]'
    o 'AWAIT INDENT Object OUTDENT' , '["await", 3]'

    # Increment/decrement (with prefix/postfix flag)
    o '-- SimpleAssignable', '["--", 2, false]'  # Prefix: --x
    o '++ SimpleAssignable', '["++", 2, false]'  # Prefix: ++x
    o 'SimpleAssignable --', '["--", 1, true]'   # Postfix: x--
    o 'SimpleAssignable ++', '["++", 1, true]'   # Postfix: x++

    # Existence check
    o 'Value ?', '["?", 1]'

    # Assignments - check for = after Value
    o 'Value = Value'       , '["=", 1, 3]'

    # Binary operators - use Value to prevent cycles!
    o 'Value + Value'       , '["+", 1, 3]'
    o 'Value - Value'       , '["-", 1, 3]'
    o 'Value MATH Value'    , '[2, 1, 3]'     # *, /, %, //, %%
    o 'Value ** Value'      , '["**", 1, 3]'
    o 'Value SHIFT Value'   , '[2, 1, 3]'     # <<, >>, >>>
    o 'Value COMPARE Value' , '[2, 1, 3]'     # ==, !=, <, >, <=, >= (== and != convert to === and !== in codegen)
    o 'Value & Value'       , '["&", 1, 3]'
    o 'Value ^ Value'       , '["^", 1, 3]'
    o 'Value | Value'       , '["|", 1, 3]'
    o 'Value && Value'      , '["&&", 1, 3]'
    o 'Value || Value'      , '["||", 1, 3]'
    o 'Value ?? Value'      , '["??", 1, 3]'  # Nullish coalescing
    o 'Value !? Value'      , '["!?", 1, 3]'  # Otherwise operator (undefined-only coalescing)
    o 'Value RELATION Value', '[2, 1, 3]'     # in, of, instanceof

    # Ternary operator
    o 'Value SPACE? Value : Value', '["?:", 1, 3, 5]'

    # Postfix conditionals (low precedence)
    o 'Value POST_IF Value'     , '["if", 3, [1]]'      # Postfix if
    o 'Value POST_UNLESS Value' , '["unless", 3, [1]]'  # Postfix unless

    # Compound assignment operators - right side can stay as Expression for flexibility
    o 'SimpleAssignable COMPOUND_ASSIGN Expression'               , '[2, 1, 3]'  # +=, -=, ||=, etc.
    o 'SimpleAssignable COMPOUND_ASSIGN INDENT Expression OUTDENT', '[2, 1, 4]'
    o 'SimpleAssignable COMPOUND_ASSIGN TERMINATOR Expression'    , '[2, 1, 4]'
  ]

  # Do IIFE (immediately invoked function expression)
  DoIife: [
    o 'DO_IIFE Code', '["do-iife", 2]'
  ]

# ==============================================================================
# OPERATOR PRECEDENCE TABLE
# ==============================================================================
# This table resolves all ambiguities in the Operation rule.
# Precedence here is high to low.
# Generator must use this for precedence-climbing or operator-precedence parsing.

operators = """
  right       DO_IIFE
  left        . ?. :: ?::
  left        CALL_START CALL_END
  nonassoc    ++ --
  left        ?
  right       UNARY DO
  right       AWAIT
  right       **
  right       UNARY_MATH
  left        MATH
  left        + -
  left        SHIFT
  left        RELATION
  left        COMPARE
  left        &
  left        ^
  left        |
  left        &&
  left        ||
  right       SPACE?
  nonassoc    INDENT OUTDENT
  right       YIELD
  right       = : COMPOUND_ASSIGN RETURN THROW EXTENDS
  right       FORIN FOROF FORFROM BY WHEN
  right       IF ELSE FOR WHILE UNTIL LOOP SUPER CLASS IMPORT EXPORT DYNAMIC_IMPORT
  left        POST_IF
""".trim().split('\n').reverse().map (line) -> line.trim().split /\s+/

# Wrapping Up
# -----------

# Export the processed grammar and operators for the parser generator. Unlike
# the original implementation, we no longer extract and pass tokens separately,
# the parser generator can derive them automatically from the BNF grammar.
export default {mode, grammar, operators}
