// Predictive Recursive Descent Parser generated by Solar 1.4.0 (RD mode)

class Parser {
  constructor() {
    this.la = null;        // Current lookahead token
    this.lexer = null;     // Lexer instance
    this.yy = {};          // Shared state
    this.depth = 0;        // Recursion depth tracking
    this.maxDepth = 1000;  // Maximum recursion depth (prevent stack overflow)
  }

  // Initialize parser with input
  parse(input) {
    this.lexer = this._createLexer();
    this.lexer.setInput(input, this.yy);
    this.la = this._nextToken();
    const result = this.parseRoot();
  if (this.la.kind !== '$end') {
    this._error(['$end'], 'Expected end of input');
  }
  return result;
}

// Get next token from lexer
_nextToken() {
  const tok = this.lexer.lex() || '$end';
  const kind = typeof tok === 'number' ? this._tokenName(tok) : tok;
  return {
    kind: kind,
    value: this.lexer.yytext,
    line: this.lexer.yylineno,
    column: this.lexer.yylloc?.first_column || 0
  };
}

// Match expected token and advance
_match(kind) {
  if (this.la.kind !== kind) {
    this._error([kind], `Expected ${kind}`);
  }
  const tok = this.la;
  this.la = this._nextToken();
  // Return the SAVED token's value, not current lexer value!
  // tok.value is the matched token's value BEFORE advancing
  return tok.value;
}

// Check if current token is in set
_check(...kinds) {
  return kinds.includes(this.la.kind);
}

// Error handling
_error(expected, msg) {
  const line = this.la.line + 1;
  const col = this.la.column;
  const token = this.la.kind;
  throw new Error(
    `Parse error at line ${line}, column ${col}: ${msg}\n` +
    `Got '${token}', expected one of: ${expected.join(', ')}`
  );
}

// Token name lookup
_tokenName(id) {
  const names = {"2":"error","7":"TERMINATOR","12":"STATEMENT","25":"DEF","27":"CALL_START","29":"CALL_END","34":"YIELD","35":"INDENT","37":"OUTDENT","38":"FROM","39":"IDENTIFIER","41":"PROPERTY","43":"NUMBER","45":"STRING","46":"STRING_START","48":"STRING_END","51":"INTERPOLATION_START","52":"INTERPOLATION_END","54":"REGEX","55":"REGEX_START","57":"REGEX_END","59":",","61":"JS","62":"UNDEFINED","63":"NULL","64":"BOOL","65":"INFINITY","66":"NAN","69":"=","73":":","76":"[","77":"]","78":"@","79":"...","84":"SUPER","87":"DYNAMIC_IMPORT","88":".","89":"?.","90":"::","91":"?::","92":"INDEX_START","93":"INDEX_END","94":"INDEX_SOAK","95":"RETURN","96":"PARAM_START","97":"PARAM_END","99":"->","100":"=>","110":"ES6_OPTIONAL_INDEX","114":"NEW_TARGET","115":"IMPORT_META","116":"{","117":"FOR","119":"FOROF","120":"}","121":"WHEN","122":"OWN","125":"CLASS","126":"EXTENDS","127":"IMPORT","133":"AS","134":"DEFAULT","135":"IMPORT_ALL","136":"EXPORT","138":"EXPORT_ALL","141":"ES6_OPTIONAL_CALL","142":"FUNC_EXIST","144":"THIS","149":"..","158":"TRY","160":"FINALLY","161":"CATCH","163":"THROW","164":"(","165":")","167":"WHILE","168":"UNTIL","170":"LOOP","171":"FORIN","172":"BY","173":"FORFROM","174":"AWAIT","177":"SWITCH","179":"ELSE","182":"LEADING_WHEN","184":"IF","186":"UNLESS","187":"UNARY","188":"DO","189":"DO_IIFE","190":"UNARY_MATH","191":"-","192":"+","193":"--","194":"++","195":"?","196":"MATH","197":"**","198":"SHIFT","199":"COMPARE","200":"&","201":"^","202":"|","203":"&&","204":"||","205":"??","206":"!?","207":"RELATION","208":"SPACE?","209":"COMPOUND_ASSIGN"};
  return names[id] || id;
}

// Create lexer (stub - override with actual lexer)
_createLexer() {
  if (this.lexer) return this.lexer;
  throw new Error('No lexer provided. Set parser.lexer before calling parse()');
}

// ========================================================================
// Parse Functions (one per nonterminal)
// ========================================================================

    parseRoot() {
  // Root: prefer Body over ε unless at EOF
  if (this.la.kind !== '$end') {
    const $$1 = this.parseBody();
    return ["program", ...$$1];
  }
  // ε production (empty program)
  return ["program"];
}

parseBody() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseBody(). Possible grammar cycle.");
}
try {
// List pattern: Body → Line BodyTail
    const $$1 = this.parseLine();
const $$2 = this.parseBodyTail();
    return [$$1, ...$$2];  } finally {
    this.depth--;
  }
}

  parseBodyTail() {
    if (this.la.kind === 'TERMINATOR') {
      this._match('TERMINATOR');
      // Check if next token can start Line
      if (['IF', 'UNLESS', 'FOR', 'TRY', 'SWITCH', 'DEF', 'CLASS', 'PARAM_START', 'UNARY', 'DO', 'UNARY_MATH', '-', '+', 'AWAIT', '--', '++', 'WHILE', 'UNTIL', 'LOOP', '->', '=>', 'JS', 'UNDEFINED', 'NULL', 'BOOL', 'INFINITY', 'NAN', '(', '[', 'SUPER', 'DYNAMIC_IMPORT', 'DO_IIFE', 'THIS', '@', 'NEW_TARGET', 'IMPORT_META', 'IDENTIFIER', '{', 'NUMBER', 'STRING', 'STRING_START', 'REGEX', 'REGEX_START', 'RETURN', 'STATEMENT', 'IMPORT', 'EXPORT'].includes(this.la.kind)) {
        // Rule: TERMINATOR Line BodyTail
        const elem = this.parseLine();
        const tail = this.parseBodyTail();
        return [elem, ...tail];
      } else {
        // Rule: TERMINATOR BodyTail (skip separator, continue)
        const tail = this.parseBodyTail();
        return [...tail];
      }
    } else {
      // ε production
      return [];
    }
  }


parseLine() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseLine(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IF':
      return this.parseExpression();
    case 'UNLESS':
      return this.parseExpression();
    case 'FOR':
      return this.parseExpression();
    case 'WHILE':
      return this.parseExpression();
    case 'UNTIL':
      return this.parseExpression();
    case 'LOOP':
      return this.parseExpression();
    case 'TRY':
      return this.parseExpression();
    case 'SWITCH':
      return this.parseExpression();
    case 'DEF':
      return this.parseExpression();
    case 'CLASS':
      return this.parseExpression();
    case 'PARAM_START':
      return this.parseExpression();
    case '->':
      return this.parseExpression();
    case '=>':
      return this.parseExpression();
    case '(':
      return this.parseExpression();
    case 'UNARY':
      return this.parseExpression();
    case 'DO':
      return this.parseExpression();
    case 'UNARY_MATH':
      return this.parseExpression();
    case '-':
      return this.parseExpression();
    case '+':
      return this.parseExpression();
    case 'AWAIT':
      return this.parseExpression();
    case '--':
      return this.parseExpression();
    case '++':
      return this.parseExpression();
    case '[':
      return this.parseExpression();
    case '{':
      return this.parseExpression();
    case 'NUMBER':
      return this.parseExpression();
    case 'JS':
      return this.parseExpression();
    case 'REGEX':
      return this.parseExpression();
    case 'REGEX_START':
      return this.parseExpression();
    case 'UNDEFINED':
      return this.parseExpression();
    case 'NULL':
      return this.parseExpression();
    case 'BOOL':
      return this.parseExpression();
    case 'INFINITY':
      return this.parseExpression();
    case 'NAN':
      return this.parseExpression();
    case 'SUPER':
      return this.parseExpression();
    case 'DYNAMIC_IMPORT':
      return this.parseExpression();
    case 'DO_IIFE':
      return this.parseExpression();
    case 'THIS':
      return this.parseExpression();
    case '@':
      return this.parseExpression();
    case 'NEW_TARGET':
      return this.parseExpression();
    case 'IMPORT_META':
      return this.parseExpression();
    case 'IDENTIFIER':
      return this.parseExpression();
    case 'STRING':
      return this.parseExpression();
    case 'STRING_START':
      return this.parseExpression();
    case 'RETURN':
      return this.parseStatement();
    case 'STATEMENT':
      return this.parseStatement();
    case 'IMPORT':
      return this.parseStatement();
    case 'EXPORT':
      return this.parseStatement();default:
  this._error(['IF', 'UNLESS', 'FOR', 'WHILE', 'UNTIL', 'LOOP', 'TRY', 'SWITCH', 'DEF', 'CLASS', 'PARAM_START', '->', '=>', '(', 'UNARY', 'DO', 'UNARY_MATH', '-', '+', 'AWAIT', '--', '++', '[', '{', 'NUMBER', 'JS', 'REGEX', 'REGEX_START', 'UNDEFINED', 'NULL', 'BOOL', 'INFINITY', 'NAN', 'SUPER', 'DYNAMIC_IMPORT', 'DO_IIFE', 'THIS', '@', 'NEW_TARGET', 'IMPORT_META', 'IDENTIFIER', 'STRING', 'STRING_START', 'RETURN', 'STATEMENT', 'IMPORT', 'EXPORT'], "Invalid Line");
  }
  } finally {
    this.depth--;
  }
}

parseStatement() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseStatement(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'RETURN':
      return this.parseReturn();
    case 'STATEMENT':
      {
      const $$1 = this._match('STATEMENT');
      return $$1;
      }
    case 'IMPORT':
      return this.parseImport();
    case 'EXPORT':
      return this.parseExport();default:
  this._error(['RETURN', 'STATEMENT', 'IMPORT', 'EXPORT'], "Invalid Statement");
  }
  } finally {
    this.depth--;
  }
}

parseExpression() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseExpression(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IF':
      return this.parseIf();
    case 'UNLESS':
      return this.parseIf();
    case 'FOR':
      return this.parseFor();
    case 'TRY':
      return this.parseFor();
    case 'SWITCH':
      return this.parseFor();
    case 'DEF':
      return this.parseFor();
    case 'CLASS':
      return this.parseFor();
    case 'PARAM_START':
      return this.parseCode();
    case 'UNARY':
      return this.parseOperation();
    case 'DO':
      return this.parseOperation();
    case 'UNARY_MATH':
      return this.parseOperation();
    case '-':
      return this.parseOperation();
    case '+':
      return this.parseOperation();
    case 'AWAIT':
      return this.parseOperation();
    case '--':
      return this.parseOperation();
    case '++':
      return this.parseOperation();
    case 'WHILE':
      return this.parseFor();
    case 'UNTIL':
      return this.parseFor();
    case 'LOOP':
      return this.parseFor();
    case '->':
      return this.parseCode();
    case '=>':
      return this.parseCode();
    case 'JS':
      return this.parseOperation();
    case 'UNDEFINED':
      return this.parseOperation();
    case 'NULL':
      return this.parseOperation();
    case 'BOOL':
      return this.parseOperation();
    case 'INFINITY':
      return this.parseOperation();
    case 'NAN':
      return this.parseOperation();
    case '(':
      return this.parseOperation();
    case '[':
      return this.parseOperation();
    case 'SUPER':
      return this.parseOperation();
    case 'DYNAMIC_IMPORT':
      return this.parseOperation();
    case 'DO_IIFE':
      return this.parseOperation();
    case 'THIS':
      return this.parseOperation();
    case '@':
      return this.parseOperation();
    case 'NEW_TARGET':
      return this.parseOperation();
    case 'IMPORT_META':
      return this.parseOperation();
    case 'IDENTIFIER':
      return this.parseOperation();
    case '{':
      return this.parseOperation();
    case 'NUMBER':
      return this.parseOperation();
    case 'STRING':
      return this.parseOperation();
    case 'STRING_START':
      return this.parseOperation();
    case 'REGEX':
      return this.parseOperation();
    case 'REGEX_START':
      return this.parseOperation();default:
  this._error(['IF', 'UNLESS', 'FOR', 'TRY', 'SWITCH', 'DEF', 'CLASS', 'PARAM_START', 'UNARY', 'DO', 'UNARY_MATH', '-', '+', 'AWAIT', '--', '++', 'WHILE', 'UNTIL', 'LOOP', '->', '=>', 'JS', 'UNDEFINED', 'NULL', 'BOOL', 'INFINITY', 'NAN', '(', '[', 'SUPER', 'DYNAMIC_IMPORT', 'DO_IIFE', 'THIS', '@', 'NEW_TARGET', 'IMPORT_META', 'IDENTIFIER', '{', 'NUMBER', 'STRING', 'STRING_START', 'REGEX', 'REGEX_START'], "Invalid Expression");
  }
  } finally {
    this.depth--;
  }
}

parsePrimaryExpression() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parsePrimaryExpression(). Possible grammar cycle.");
}
try {
    const $$1 = this.parseOperation();
      return $$1;  } finally {
    this.depth--;
  }
}

parseDef() {
  // Parse common prefix
  const $$1 = this._match('DEF');
  const $$2 = this.parseIdentifier();

  // Lookahead to decide which alternative
  if (this.la.kind === 'CALL_START') {
    // With params: DEF Identifier CALL_START ParamList CALL_END Block
    const $$3 = this._match('CALL_START');
    const $$4 = this.parseParamList();
    const $$5 = this._match('CALL_END');
    const $$6 = this.parseBlock();
    return ["def", $$2, $$4, $$6];
  } else {
    // No params: DEF Identifier Block
    const $$3 = this.parseBlock();
    return ["def", $$2, [], $$3];
  }
}

parseExpressionLine() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseExpressionLine(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'PARAM_START':
      {
      const $$1 = this.parseCodeLine();
      return $$1;
      }
    case '->':
      {
      const $$1 = this.parseCodeLine();
      return $$1;
      }
    case '=>':
      {
      const $$1 = this.parseCodeLine();
      return $$1;
      }
    case 'UNARY':
      {
      const $$1 = this.parseOperationLine();
      return $$1;
      }
    case 'DO':
      {
      const $$1 = this.parseOperationLine();
      return $$1;
      }
    case 'DO_IIFE':
      {
      const $$1 = this.parseOperationLine();
      return $$1;
      }default:      this._error(['PARAM_START', '->', '=>', 'UNARY', 'DO', 'DO_IIFE'], "Invalid ExpressionLine");  }
  } finally {
    this.depth--;
  }
}

parseYield() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseYield(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'YIELD':
      {
      const $$1 = this._match('YIELD');
      return ["yield"];
      }default:      this._error(['YIELD'], "Invalid Yield");  }
  } finally {
    this.depth--;
  }
}

parseBlock() {
  // Parse INDENT
  const $$1 = this._match('INDENT');

  // Lookahead to decide which alternative
  if (this.la.kind === 'OUTDENT') {
    // Empty block: INDENT OUTDENT
    const $$2 = this._match('OUTDENT');
    return ["block"];
  } else {
    // Block with body: INDENT Body OUTDENT
    const $$2 = this.parseBody();
    const $$3 = this._match('OUTDENT');
    return ["block", ...$$2];
  }
}

parseIdentifier() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseIdentifier(). Possible grammar cycle.");
}
try {
    const $$1 = this._match('IDENTIFIER');
      return $$1;  } finally {
    this.depth--;
  }
}

parseProperty() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseProperty(). Possible grammar cycle.");
}
try {
    const $$1 = this._match('PROPERTY');
      return $$1;  } finally {
    this.depth--;
  }
}

parseAlphaNumeric() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseAlphaNumeric(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'NUMBER':
      {
      const $$1 = this._match('NUMBER');
      return $$1;
      }
    case 'STRING':
      {
      const $$1 = this.parseString();
      return $$1;
      }
    case 'STRING_START':
      {
      const $$1 = this.parseString();
      return $$1;
      }default:      this._error(['NUMBER', 'STRING', 'STRING_START'], "Invalid AlphaNumeric");  }
  } finally {
    this.depth--;
  }
}

parseString() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseString(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'STRING':
      {
      const $$1 = this._match('STRING');
      return $$1;
      }
    case 'STRING_START':
      {
      const $$1 = this._match('STRING_START');
      const $$2 = this.parseInterpolations();
      const $$3 = this._match('STRING_END');
      return ["str", ...$$2];
      }default:      this._error(['STRING', 'STRING_START'], "Invalid String");  }
  } finally {
    this.depth--;
  }
}

parseInterpolations() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseInterpolations(). Possible grammar cycle.");
}
try {
// List pattern: Interpolations → InterpolationChunk InterpolationsTail
    const $$1 = this.parseInterpolationChunk();
const $$2 = this.parseInterpolationsTail();
    return [$$1, ...$$2];  } finally {
    this.depth--;
  }
}

parseInterpolationsTail() {
switch (this.la.kind) {    case 'INTERPOLATION_START':
      {
      const $$1 = this.parseInterpolationChunk();
      const $$2 = this.parseInterpolationsTail();
      return [$$1, ...$$2];
      }
    case 'STRING':
      {
      const $$1 = this.parseInterpolationChunk();
      const $$2 = this.parseInterpolationsTail();
      return [$$1, ...$$2];
      }
    case 'STRING_START':
      {
      const $$1 = this.parseInterpolationChunk();
      const $$2 = this.parseInterpolationsTail();
      return [$$1, ...$$2];
      }default:      // ε production
      return [];  }
}

parseInterpolationChunk() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseInterpolationChunk(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'INTERPOLATION_START':
      {
      const $$1 = this._match('INTERPOLATION_START');
      const $$2 = this._match('INTERPOLATION_END');
      return "";
      }
    case 'STRING':
      {
      const $$1 = this.parseString();
      return $$1;
      }
    case 'STRING_START':
      {
      const $$1 = this.parseString();
      return $$1;
      }default:      this._error(['INTERPOLATION_START', 'STRING', 'STRING_START'], "Invalid InterpolationChunk");  }
  } finally {
    this.depth--;
  }
}

parseRegex() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseRegex(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'REGEX':
      {
      const $$1 = this._match('REGEX');
      return $$1;
      }
    case 'REGEX_START':
      {
      const $$1 = this._match('REGEX_START');
      const $$2 = this.parseInvocation();
      const $$3 = this._match('REGEX_END');
      return ["regex", $$2];
      }default:      this._error(['REGEX', 'REGEX_START'], "Invalid Regex");  }
  } finally {
    this.depth--;
  }
}

parseRegexWithIndex() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseRegexWithIndex(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'REGEX':
      {
      const $$1 = this.parseRegex();
      return ["regex-index", $$1, null];
      }
    case 'REGEX_START':
      {
      const $$1 = this.parseRegex();
      return ["regex-index", $$1, null];
      }default:      this._error(['REGEX', 'REGEX_START'], "Invalid RegexWithIndex");  }
  } finally {
    this.depth--;
  }
}

parseLiteral() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseLiteral(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'NUMBER':
      {
      const $$1 = this.parseAlphaNumeric();
      return $$1;
      }
    case 'STRING':
      {
      const $$1 = this.parseAlphaNumeric();
      return $$1;
      }
    case 'STRING_START':
      {
      const $$1 = this.parseAlphaNumeric();
      return $$1;
      }
    case 'JS':
      {
      const $$1 = this._match('JS');
      return $$1;
      }
    case 'REGEX':
      {
      const $$1 = this.parseRegex();
      return $$1;
      }
    case 'REGEX_START':
      {
      const $$1 = this.parseRegex();
      return $$1;
      }
    case 'UNDEFINED':
      {
      const $$1 = this._match('UNDEFINED');
      return "undefined";
      }
    case 'NULL':
      {
      const $$1 = this._match('NULL');
      return "null";
      }
    case 'BOOL':
      {
      const $$1 = this._match('BOOL');
      return $$1;
      }
    case 'INFINITY':
      {
      const $$1 = this._match('INFINITY');
      return $$1;
      }
    case 'NAN':
      {
      const $$1 = this._match('NAN');
      return $$1;
      }default:      this._error(['NUMBER', 'STRING', 'STRING_START', 'JS', 'REGEX', 'REGEX_START', 'UNDEFINED', 'NULL', 'BOOL', 'INFINITY', 'NAN'], "Invalid Literal");  }
  } finally {
    this.depth--;
  }
}

parseAssign() {
  // Parse Assignable
  const lhs = this.parseAssignable();

  // Match = token
  this._match('=');

  // Check for optional TERMINATOR or INDENT
  if (this.la.kind === 'TERMINATOR') {
    this._match('TERMINATOR');
    const rhs = this.parseExpression();
    return ["=", lhs, rhs];
  } else if (this.la.kind === 'INDENT') {
    this._match('INDENT');
    const rhs = this.parseExpression();
    this._match('OUTDENT');
    return ["=", lhs, rhs];
  } else {
    // Simple assignment: Assignable = Expression
    const rhs = this.parseExpression();
    return ["=", lhs, rhs];
  }
}

parseAssignObj() {
  // Check for rest spread: {...rest}
  if (this.la.kind === '...') {
    return this.parseObjRestValue();
  }

  // Parse the key (ObjAssignable or SimpleObjAssignable)
  let key;
  if (this.la.kind === 'IDENTIFIER' || this.la.kind === 'PROPERTY' || this.la.kind === '@' ||
      this.la.kind === '[' || this.la.kind === 'NUMBER' || this.la.kind === 'STRING' || this.la.kind === 'STRING_START') {

    // For default values, we need SimpleObjAssignable
    if (this.la.kind === 'IDENTIFIER' || this.la.kind === 'PROPERTY' || this.la.kind === '@') {
      key = this.parseSimpleObjAssignable();
    } else {
      key = this.parseObjAssignable();
    }

    // Check what follows the key
    if (this.la.kind === ':') {
      // Property with value: {a: 1}
      this._match(':');
      if (this.la.kind === 'INDENT') {
        this._match('INDENT');
        const value = this.parseExpression();
        this._match('OUTDENT');
        return [key, value, ":"];
      } else {
        const value = this.parseExpression();
        return [key, value, ":"];
      }
    } else if (this.la.kind === '=') {
      // Default value: {a = 5}
      this._match('=');
      if (this.la.kind === 'INDENT') {
        this._match('INDENT');
        const value = this.parseExpression();
        this._match('OUTDENT');
        return [key, value, "="];
      } else {
        const value = this.parseExpression();
        return [key, value, "="];
      }
    } else {
      // Property shorthand: {x}
      return [key, key, null];
    }
  }

  this._error([], "Invalid AssignObj");
}

parseSimpleObjAssignable() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseSimpleObjAssignable(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IDENTIFIER':
      return this.parseIdentifier();
    case 'PROPERTY':
      return this.parseProperty();
    case '@':
      return this.parseThisProperty();default:
  this._error(['IDENTIFIER', 'PROPERTY', '@'], "Invalid SimpleObjAssignable");
  }
  } finally {
    this.depth--;
  }
}

parseObjAssignable() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseObjAssignable(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IDENTIFIER':
      return this.parseSimpleObjAssignable();
    case 'PROPERTY':
      return this.parseSimpleObjAssignable();
    case '@':
      return this.parseSimpleObjAssignable();
    case '[':
      {
      const $$1 = this._match('[');
      const $$2 = this.parseExpression();
      const $$3 = this._match(']');
      return ["computed", $$2];
      }
    case 'NUMBER':
      return this.parseAlphaNumeric();
    case 'STRING':
      return this.parseAlphaNumeric();
    case 'STRING_START':
      return this.parseAlphaNumeric();default:
  this._error(['IDENTIFIER', 'PROPERTY', '@', '[', 'NUMBER', 'STRING', 'STRING_START'], "Invalid ObjAssignable");
  }
  } finally {
    this.depth--;
  }
}

parseObjRestValue() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseObjRestValue(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case '...':
      {
      const $$1 = this._match('...');
      const $$2 = this.parseSimpleObjAssignable();
      return ["...", $$2];
      }default:      this._error(['...'], "Invalid ObjRestValue");  }
  } finally {
    this.depth--;
  }
}

parseObjSpreadExpr() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseObjSpreadExpr(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IDENTIFIER':
      {
      const $$1 = this.parseSimpleObjAssignable();
      return $$1;
      }
    case 'PROPERTY':
      {
      const $$1 = this.parseSimpleObjAssignable();
      return $$1;
      }
    case '@':
      {
      const $$1 = this.parseSimpleObjAssignable();
      return $$1;
      }
    case '{':
      {
      const $$1 = this.parseObject();
      return $$1;
      }
    case '(':
      {
      const $$1 = this.parseParenthetical();
      return $$1;
      }
    case 'SUPER':
      {
      const $$1 = this._match('SUPER');
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseArguments();
      return ["super", ...$$3];
      }
    case 'THIS':
      {
      const $$1 = this.parseThis();
      return $$1;
      }
    case 'DYNAMIC_IMPORT':
      {
      const $$1 = this._match('DYNAMIC_IMPORT');
      const $$2 = this.parseArguments();
      return ["import", ...$$2];
      }default:      this._error(['IDENTIFIER', 'PROPERTY', '@', '{', '(', 'SUPER', 'THIS', 'DYNAMIC_IMPORT'], "Invalid ObjSpreadExpr");  }
  } finally {
    this.depth--;
  }
}// NOTE: Simplified - omitted 11 accessor patterns

parseReturn() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseReturn(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'RETURN':
      {
      const $$1 = this._match('RETURN');
      return ["return"];
      }default:      this._error(['RETURN'], "Invalid Return");  }
  } finally {
    this.depth--;
  }
}

parseCode() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseCode(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'PARAM_START':
      {
      const $$1 = this._match('PARAM_START');
      const $$2 = this.parseParamList();
      const $$3 = this._match('PARAM_END');
      const $$4 = this.parseFuncGlyph();
      const $$5 = this.parseBlock();
      return [$$4, $$2, $$5];
      }
    case '->':
      {
      const $$1 = this.parseFuncGlyph();
      const $$2 = this.parseBlock();
      return [$$1, [], $$2];
      }
    case '=>':
      {
      const $$1 = this.parseFuncGlyph();
      const $$2 = this.parseBlock();
      return [$$1, [], $$2];
      }default:      this._error(['PARAM_START', '->', '=>'], "Invalid Code");  }
  } finally {
    this.depth--;
  }
}

parseCodeLine() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseCodeLine(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'PARAM_START':
      {
      const $$1 = this._match('PARAM_START');
      const $$2 = this.parseParamList();
      const $$3 = this._match('PARAM_END');
      const $$4 = this.parseFuncGlyph();
      const $$5 = this.parseLine();
      return [$$4, $$2, $$5];
      }
    case '->':
      {
      const $$1 = this.parseFuncGlyph();
      const $$2 = this.parseLine();
      return [$$1, [], $$2];
      }
    case '=>':
      {
      const $$1 = this.parseFuncGlyph();
      const $$2 = this.parseLine();
      return [$$1, [], $$2];
      }default:      this._error(['PARAM_START', '->', '=>'], "Invalid CodeLine");  }
  } finally {
    this.depth--;
  }
}

parseFuncGlyph() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseFuncGlyph(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case '->':
      {
      const $$1 = this._match('->');
      return $$1;
      }
    case '=>':
      {
      const $$1 = this._match('=>');
      return $$1;
      }default:      this._error(['->', '=>'], "Invalid FuncGlyph");  }
  } finally {
    this.depth--;
  }
}

parseOptComma() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseOptComma(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      return $$1;
      }default:      // ε production
      return null;  }
  } finally {
    this.depth--;
  }
}

parseParamList() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseParamList(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IDENTIFIER':
      {
      const $$1 = this.parseParam();
      const $$2 = this.parseParamListTail();
      return [$$1, ...$$2];
      }
    case '@':
      {
      const $$1 = this.parseParam();
      const $$2 = this.parseParamListTail();
      return [$$1, ...$$2];
      }
    case '[':
      {
      const $$1 = this.parseParam();
      const $$2 = this.parseParamListTail();
      return [$$1, ...$$2];
      }
    case '{':
      {
      const $$1 = this.parseParam();
      const $$2 = this.parseParamListTail();
      return [$$1, ...$$2];
      }
    case '...':
      {
      const $$1 = this.parseParam();
      const $$2 = this.parseParamListTail();
      return [$$1, ...$$2];
      }
    case 'INDENT':
      {
      const $$1 = this._match('INDENT');
      const $$2 = this.parseParamList();
      const $$3 = this.parseOptComma();
      const $$4 = this._match('OUTDENT');
      return $$2;
      }default:      // ε production
      return [];  }
  } finally {
    this.depth--;
  }
}

parseParamListTail() {
switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      const $$2 = this.parseParam();
      const $$3 = this.parseParamListTail();
      return [$$2, ...$$3];
      }
    case 'TERMINATOR':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('TERMINATOR');
      const $$3 = this.parseParam();
      const $$4 = this.parseParamListTail();
      return [$$3, ...$$4];
      }
    case 'INDENT':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('INDENT');
      const $$3 = this.parseParamList();
      const $$4 = this.parseOptComma();
      const $$5 = this._match('OUTDENT');
      return [...$$3];
      }default:      // ε production
      return [];  }
}

parseParam() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseParam(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IDENTIFIER':
      {
      const $$1 = this.parseParamVar();
      return $$1;
      }
    case '@':
      {
      const $$1 = this.parseParamVar();
      return $$1;
      }
    case '[':
      {
      const $$1 = this.parseParamVar();
      return $$1;
      }
    case '{':
      {
      const $$1 = this.parseParamVar();
      return $$1;
      }
    case '...':
      {
      const $$1 = this._match('...');
      return ["expansion"];
      }default:      this._error(['IDENTIFIER', '@', '[', '{', '...'], "Invalid Param");  }
  } finally {
    this.depth--;
  }
}

parseParamVar() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseParamVar(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IDENTIFIER':
      return this.parseIdentifier();
    case '@':
      return this.parseThisProperty();
    case '[':
      return this.parseArray();
    case '{':
      return this.parseObject();default:
  this._error(['IDENTIFIER', '@', '[', '{'], "Invalid ParamVar");
  }
  } finally {
    this.depth--;
  }
}

parseSplat() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseSplat(). Possible grammar cycle.");
}
try {
    const $$1 = this._match('...');
      const $$2 = this.parseExpression();
      return ["...", $$2];  } finally {
    this.depth--;
  }
}

parseSimpleAssignable() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseSimpleAssignable(). Possible grammar cycle.");
}
try {
  // Accessor chain with full iterative loop
  let base;

  // Parse base case
  switch (this.la.kind) {    case 'IDENTIFIER':
      {
      const $$1 = this.parseIdentifier();
      base = $$1;;
      break;
      }
    case '@':
      {
      const $$1 = this.parseThisProperty();
      base = $$1;;
      break;
      }default:
  this._error([], "Invalid SimpleAssignable");
}

// Iterate through accessors
while (true) {
  switch (this.la.kind) {      case '.':
        this._match('.');
        const prop = this.parseProperty();
        base = ['.', base, prop];
        break;
      case '?.':
        this._match('?.');
        const optProp = this.parseProperty();
        base = ['?.', base, optProp];
        break;
      case '::':
        this._match('::');
        if (this.la.kind === 'PROPERTY') {
          const protoProp = this.parseProperty();
          base = ['::', base, protoProp];
        } else {
          base = ['::', base, 'prototype'];
        }
        break;
      case '?::':
        this._match('?::');
        if (this.la.kind === 'PROPERTY') {
          const optProtoProp = this.parseProperty();
          base = ['?::', base, optProtoProp];
        } else {
          base = ['?::', base, 'prototype'];
        }
        break;
      case 'INDEX_START':
        this._match('INDEX_START');
        // Check for slice vs simple index
        if (this.la.kind === '..' || this.la.kind === '...') {
          // Slice without start: [..3] or [...3]
          const slice = this.parseSlice();
          this._match('INDEX_END');
          base = ['[]', base, slice];
        } else {
          const index = this.parseExpression();
          // Check if it's a slice: [1..3] or [1...3]
          if (this.la.kind === '..' || this.la.kind === '...') {
            // It's a slice! Parse as Slice
            const dots = this.parseRangeDots();
            let endExpr = null;
            if (this.la.kind !== 'INDEX_END') {
              endExpr = this.parseExpression();
            }
            this._match('INDEX_END');
            base = ['[]', base, [dots, index, endExpr]];
          } else {
            // Simple index
            this._match('INDEX_END');
            base = ['[]', base, index];
          }
        }
        break;
      case 'INDEX_SOAK':
        this._match('INDEX_SOAK');
        this._match('INDEX_START');
        const soakIndex = this.parseExpression();
        this._match('INDEX_END');
        base = ['?[]', base, soakIndex];
        break;      default:
        return base;
    }
  }
  } finally {
    this.depth--;
  }
}

parseAssignable() {
  switch (this.la.kind) {
    case 'IDENTIFIER':
    case '@':
      return this.parseSimpleAssignable();
    case '[':
      return this.parseArray();
    case '{':
      return this.parseObject();
    default:
      this._error(['IDENTIFIER', '@', '[', '{'], "Invalid Assignable");
  }
}

parseValue() {
  // Parse base value
  let base;
  switch (this.la.kind) {
    case 'IDENTIFIER':
    case '{':
    case 'SUPER':
    case 'DYNAMIC_IMPORT':
    case 'DO_IIFE':
      base = this.parseAssignable();
      break;
    case '@':
      // Bare @ alone means "this", but @ followed by more is @property
      this._match('@');
      if (this.la.kind === 'PROPERTY') {
        // @property - parse as this.property
        const prop = this.parseProperty();
        base = ['.', 'this', prop];
      } else {
        // Bare @ means "this"
        base = "this";
      }
      break;
    case 'THIS':
      // THIS keyword maps to "this"
      this._match('THIS');
      base = "this";
      break;
    case 'NEW_TARGET':
    case 'IMPORT_META':
      base = this.parseMetaProperty();
      break;
    case '[':
      // Could be Array or Range - try Range first (it's more specific)
      // Range: [ Expression .. Expression ]
      // Array: [ ... ]
      // We need to lookahead to distinguish, but for now just try Array
      // (Range will be handled if Array sees .. or ...)
      base = this.parseAssignable();
      break;
    case '(':
      // Could be Parenthetical or Assignable with paren
      base = this.parseParenthetical();
      break;
    case 'NUMBER':
    case 'STRING':
    case 'STRING_START':
    case 'JS':
    case 'UNDEFINED':
    case 'NULL':
    case 'BOOL':
    case 'INFINITY':
    case 'NAN':
    case 'REGEX':
    case 'REGEX_START':
      base = this.parseLiteral();
      break;
    default:
      this._error([], "Invalid Value");
  }

  // Handle function calls and accessors iteratively
  while (true) {
    if (this.la.kind === 'CALL_START' || this.la.kind === 'FUNC_EXIST' || this.la.kind === 'ES6_OPTIONAL_CALL') {
      // Function call
      let funcExist = null;
      if (this.la.kind === 'FUNC_EXIST') {
        this._match('FUNC_EXIST');
        funcExist = true;
      } else if (this.la.kind === 'ES6_OPTIONAL_CALL') {
        this._match('ES6_OPTIONAL_CALL');
        const args = this.parseArguments();
        base = ["optcall", base, ...args];
        continue;
      }

      // Parse Arguments manually (CALL_START ... CALL_END)
      this._match('CALL_START');
      let args = [];
      if (this.la.kind !== 'CALL_END') {
        args = this.parseArgList();
        if (this.la.kind === ',') {
          this._match(',');  // Optional trailing comma
        }
      }
      this._match('CALL_END');

      base = funcExist ? ["?call", base, ...args] : [base, ...args];
    } else if (this.la.kind === '.') {
      // Property access: value.property
      this._match('.');
      const prop = this.parseProperty();
      base = ['.', base, prop];
    } else if (this.la.kind === '?.') {
      // Optional property access: value?.property
      this._match('?.');
      const optProp = this.parseProperty();
      base = ['?.', base, optProp];
    } else if (this.la.kind === '::') {
      // Prototype access: value::property or value::
      this._match('::');
      if (this.la.kind === 'PROPERTY') {
        const protoProp = this.parseProperty();
        base = ['::', base, protoProp];
      } else {
        base = ['::', base, 'prototype'];
      }
    } else if (this.la.kind === '?::') {
      // Optional prototype access: value?::property or value?::
      this._match('?::');
      if (this.la.kind === 'PROPERTY') {
        const optProtoProp = this.parseProperty();
        base = ['?::', base, optProtoProp];
      } else {
        base = ['?::', base, 'prototype'];
      }
    } else if (this.la.kind === 'INDEX_START') {
      // Array indexing or slicing: value[index] or value[start..end]
      this._match('INDEX_START');
      // Check for slice vs simple index
      if (this.la.kind === '..' || this.la.kind === '...') {
        // Slice without start: [..3] or [...3]
        const slice = this.parseSlice();
        this._match('INDEX_END');
        base = ['[]', base, slice];
      } else {
        const index = this.parseExpression();
        // Check if it's a slice: [1..3] or [1...3]
        if (this.la.kind === '..' || this.la.kind === '...') {
          // It's a slice! Parse as Slice
          const dots = this.parseRangeDots();
          let endExpr = null;
          if (this.la.kind !== 'INDEX_END') {
            endExpr = this.parseExpression();
          }
          this._match('INDEX_END');
          base = ['[]', base, [dots, index, endExpr]];
        } else {
          // Simple index
          this._match('INDEX_END');
          base = ['[]', base, index];
        }
      }
    } else if (this.la.kind === 'INDEX_SOAK') {
      // Optional indexing: value?[index]
      this._match('INDEX_SOAK');
      this._match('INDEX_START');
      const soakIndex = this.parseExpression();
      this._match('INDEX_END');
      base = ['?[]', base, soakIndex];
    } else if (this.la.kind === 'ES6_OPTIONAL_INDEX') {
      // ES6 optional indexing: value?.[index]
      this._match('ES6_OPTIONAL_INDEX');
      this._match('INDEX_START');
      const optIndex = this.parseExpression();
      this._match('INDEX_END');
      base = ['optindex', base, optIndex];
    } else {
      // No more accessors or calls
      break;
    }
  }

  return base;
}

parseSuper() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseSuper(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'SUPER':
      {
      const $$1 = this._match('SUPER');
      const $$2 = this._match('.');
      const $$3 = this.parseProperty();
      return [".", "super", $$3];
      }default:      this._error(['SUPER'], "Invalid Super");  }
  } finally {
    this.depth--;
  }
}

parseMetaProperty() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseMetaProperty(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'NEW_TARGET':
      {
      const $$1 = this._match('NEW_TARGET');
      const $$2 = this._match('.');
      const $$3 = this.parseProperty();
      return [".", "new", $$3];
      }
    case 'IMPORT_META':
      {
      const $$1 = this._match('IMPORT_META');
      const $$2 = this._match('.');
      const $$3 = this.parseProperty();
      return [".", "import", $$3];
      }default:      this._error(['NEW_TARGET', 'IMPORT_META'], "Invalid MetaProperty");  }
  } finally {
    this.depth--;
  }
}

parseObject() {
  this._match('{');

  // Check for empty object
  if (this.la.kind === '}') {
    this._match('}');
    return ["object"];
  }

  // Parse object properties
  const list = this.parseAssignList();

  // Optional trailing comma
  if (this.la.kind === ',') {
    this._match(',');
  }

  this._match('}');
  return ["object", ...list];
}

parseAssignList() {
  // Check for empty object
  if (this.la.kind === '}' || this.la.kind === 'OUTDENT') {
    return [];  // Empty object
  }

  // Check for INDENT case (multiline)
  if (this.la.kind === 'INDENT') {
    this._match('INDENT');
    const list = this.parseAssignList();  // Recursive for multiline
    if (this.la.kind === ',') {
      this._match(',');  // Optional trailing comma
    }
    this._match('OUTDENT');
    return list;
  }

  // Parse first property
  const list = [];
  list.push(this.parseAssignObj());

  // Parse remaining properties
  while (this.la.kind === ',' || this.la.kind === 'TERMINATOR') {
    if (this.la.kind === 'TERMINATOR') {
      // Multiline within list (newline-separated properties)
      this._match('TERMINATOR');
      if (this.la.kind === '}' || this.la.kind === 'OUTDENT') {
        break;  // End of list
      }
      list.push(this.parseAssignObj());
    } else {
      // Comma-separated properties
      this._match(',');
      // Check for trailing comma
      if (this.la.kind === '}' || this.la.kind === 'OUTDENT') {
        break;  // Trailing comma before end
      }
      list.push(this.parseAssignObj());
    }
  }

  return list;
}

parseAssignListTail() {
switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      const $$2 = this.parseAssignObj();
      const $$3 = this.parseAssignListTail();
      return [$$2, ...$$3];
      }
    case 'TERMINATOR':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('TERMINATOR');
      const $$3 = this.parseAssignObj();
      const $$4 = this.parseAssignListTail();
      return [$$3, ...$$4];
      }
    case 'INDENT':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('INDENT');
      const $$3 = this.parseAssignList();
      const $$4 = this.parseOptComma();
      const $$5 = this._match('OUTDENT');
      return [...$$3];
      }default:      // ε production
      return [];  }
}

parseClass() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseClass(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'CLASS':
      {
      const $$1 = this._match('CLASS');
      return ["class", null, null];
      }default:      this._error(['CLASS'], "Invalid Class");  }
  } finally {
    this.depth--;
  }
}

parseImport() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseImport(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IMPORT':
      {
      const $$1 = this._match('IMPORT');
      const $$2 = this.parseString();
      return ["import", "{}", $$2];
      }default:      this._error(['IMPORT'], "Invalid Import");  }
  } finally {
    this.depth--;
  }
}

parseImportSpecifierList() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseImportSpecifierList(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IDENTIFIER':
      {
      const $$1 = this.parseImportSpecifier();
      const $$2 = this.parseImportSpecifierListTail();
      return [$$1, ...$$2];
      }
    case 'DEFAULT':
      {
      const $$1 = this.parseImportSpecifier();
      const $$2 = this.parseImportSpecifierListTail();
      return [$$1, ...$$2];
      }
    case 'INDENT':
      {
      const $$1 = this._match('INDENT');
      const $$2 = this.parseImportSpecifierList();
      const $$3 = this.parseOptComma();
      const $$4 = this._match('OUTDENT');
      return $$2;
      }default:      this._error(['IDENTIFIER', 'DEFAULT', 'INDENT'], "Invalid ImportSpecifierList");  }
  } finally {
    this.depth--;
  }
}

parseImportSpecifierListTail() {
switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      const $$2 = this.parseImportSpecifier();
      const $$3 = this.parseImportSpecifierListTail();
      return [$$2, ...$$3];
      }
    case 'TERMINATOR':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('TERMINATOR');
      const $$3 = this.parseImportSpecifier();
      const $$4 = this.parseImportSpecifierListTail();
      return [$$3, ...$$4];
      }
    case 'INDENT':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('INDENT');
      const $$3 = this.parseImportSpecifierList();
      const $$4 = this.parseOptComma();
      const $$5 = this._match('OUTDENT');
      return [...$$3];
      }default:      // ε production
      return [];  }
}

parseImportSpecifier() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseImportSpecifier(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IDENTIFIER':
      {
      const $$1 = this.parseIdentifier();
      return $$1;
      }
    case 'DEFAULT':
      {
      const $$1 = this._match('DEFAULT');
      return $$1;
      }default:      this._error(['IDENTIFIER', 'DEFAULT'], "Invalid ImportSpecifier");  }
  } finally {
    this.depth--;
  }
}

parseImportDefaultSpecifier() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseImportDefaultSpecifier(). Possible grammar cycle.");
}
try {
    const $$1 = this.parseIdentifier();
      return $$1;  } finally {
    this.depth--;
  }
}

parseImportNamespaceSpecifier() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseImportNamespaceSpecifier(). Possible grammar cycle.");
}
try {
    const $$1 = this._match('IMPORT_ALL');
      const $$2 = this._match('AS');
      const $$3 = this.parseIdentifier();
      return ["*", $$3];  } finally {
    this.depth--;
  }
}

parseExport() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseExport(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'EXPORT':
      {
      const $$1 = this._match('EXPORT');
      const $$2 = this.parseClass();
      return ["export", $$2];
      }default:      this._error(['EXPORT'], "Invalid Export");  }
  } finally {
    this.depth--;
  }
}

parseExportSpecifierList() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseExportSpecifierList(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IDENTIFIER':
      {
      const $$1 = this.parseExportSpecifier();
      const $$2 = this.parseExportSpecifierListTail();
      return [$$1, ...$$2];
      }
    case 'DEFAULT':
      {
      const $$1 = this.parseExportSpecifier();
      const $$2 = this.parseExportSpecifierListTail();
      return [$$1, ...$$2];
      }
    case 'INDENT':
      {
      const $$1 = this._match('INDENT');
      const $$2 = this.parseExportSpecifierList();
      const $$3 = this.parseOptComma();
      const $$4 = this._match('OUTDENT');
      return $$2;
      }default:      this._error(['IDENTIFIER', 'DEFAULT', 'INDENT'], "Invalid ExportSpecifierList");  }
  } finally {
    this.depth--;
  }
}

parseExportSpecifierListTail() {
switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      const $$2 = this.parseExportSpecifier();
      const $$3 = this.parseExportSpecifierListTail();
      return [$$2, ...$$3];
      }
    case 'TERMINATOR':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('TERMINATOR');
      const $$3 = this.parseExportSpecifier();
      const $$4 = this.parseExportSpecifierListTail();
      return [$$3, ...$$4];
      }
    case 'INDENT':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('INDENT');
      const $$3 = this.parseExportSpecifierList();
      const $$4 = this.parseOptComma();
      const $$5 = this._match('OUTDENT');
      return [...$$3];
      }default:      // ε production
      return [];  }
}

parseExportSpecifier() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseExportSpecifier(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IDENTIFIER':
      {
      const $$1 = this.parseIdentifier();
      return $$1;
      }
    case 'DEFAULT':
      {
      const $$1 = this._match('DEFAULT');
      return $$1;
      }default:      this._error(['IDENTIFIER', 'DEFAULT'], "Invalid ExportSpecifier");  }
  } finally {
    this.depth--;
  }
}

parseInvocation() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseInvocation(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IDENTIFIER':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case '@':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case '[':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case '{':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case 'NUMBER':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case 'JS':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case 'REGEX':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case 'REGEX_START':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case 'UNDEFINED':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case 'NULL':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case 'BOOL':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case 'INFINITY':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case 'NAN':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case '(':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case 'SUPER':
      {
      const $$1 = this._match('SUPER');
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseArguments();
      return $$2 ? ["?super", ...$$3] : ["super", ...$$3];
      }
    case 'DYNAMIC_IMPORT':
      {
      const $$1 = this._match('DYNAMIC_IMPORT');
      const $$2 = this.parseArguments();
      return ["import", ...$$2];
      }
    case 'DO_IIFE':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case 'THIS':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case 'NEW_TARGET':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case 'IMPORT_META':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case 'PARAM_START':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case '->':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case '=>':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case 'STRING':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }
    case 'STRING_START':
      {
      const $$1 = this.parseAssignable();
      const $$2 = this.parseOptFuncExist();
      const $$3 = this.parseString();
      return ["tagged-template", $$1, $$3];
      }default:      this._error(['IDENTIFIER', '@', '[', '{', 'NUMBER', 'JS', 'REGEX', 'REGEX_START', 'UNDEFINED', 'NULL', 'BOOL', 'INFINITY', 'NAN', '(', 'SUPER', 'DYNAMIC_IMPORT', 'DO_IIFE', 'THIS', 'NEW_TARGET', 'IMPORT_META', 'PARAM_START', '->', '=>', 'STRING', 'STRING_START'], "Invalid Invocation");  }
  } finally {
    this.depth--;
  }
}

parseOptFuncExist() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseOptFuncExist(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'FUNC_EXIST':
      {
      const $$1 = this._match('FUNC_EXIST');
      return true;
      }default:      // ε production
      return null;  }
  } finally {
    this.depth--;
  }
}

parseArguments() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseArguments(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'CALL_START':
      {
      const $$1 = this._match('CALL_START');
      const $$2 = this._match('CALL_END');
      return [];
      }default:      this._error(['CALL_START'], "Invalid Arguments");  }
  } finally {
    this.depth--;
  }
}

parseThis() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseThis(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'THIS':
      {
      const $$1 = this._match('THIS');
      return "this";
      }
    case '@':
      {
      const $$1 = this._match('@');
      return "this";
      }default:      this._error(['THIS', '@'], "Invalid This");  }
  } finally {
    this.depth--;
  }
}

parseThisProperty() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseThisProperty(). Possible grammar cycle.");
}
try {
    const $$1 = this._match('@');
      const $$2 = this.parseProperty();
      return [".", "this", $$2];  } finally {
    this.depth--;
  }
}

parseArray() {
  this._match('[');

  // Check for empty array
  if (this.la.kind === ']') {
    this._match(']');
    return ["array"];
  }

  // Check if it starts with comma (elisions only: [,,3])
  if (this.la.kind === ',') {
    const elisions = this.parseElisions();
    this._match(']');
    return ["array", ...elisions];
  }

  // Parse first element/expression
  // Could be:
  // - Start of array: [1, 2, 3]
  // - Start of range: [1..3] or [1...4]
  const firstExpr = this.parseExpression();

  // Check for range operators
  if (this.la.kind === '..' || this.la.kind === '...') {
    // It's a Range! [ Expression RangeDots Expression ]
    const dots = this.parseRangeDots();
    const secondExpr = this.parseExpression();
    this._match(']');
    return [dots, firstExpr, secondExpr];
  }

  // It's an Array - parse remaining elements
  // We already have first element, now check for more
  let list = [firstExpr];

  // Parse rest of array (commas and more elements)
  while (this.la.kind === ',') {
    this._match(',');
    // Check for trailing comma or closing bracket
    if (this.la.kind === ']') {
      break;
    }
    // Parse next element
    const elem = this.parseExpression();
    list.push(elem);
  }

  this._match(']');
  return ["array", ...list];
}

parseRangeDots() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseRangeDots(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case '..':
      {
      const $$1 = this._match('..');
      return "..";
      }
    case '...':
      {
      const $$1 = this._match('...');
      return "...";
      }default:      this._error(['..', '...'], "Invalid RangeDots");  }
  } finally {
    this.depth--;
  }
}

parseRange() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseRange(). Possible grammar cycle.");
}
try {
    const $$1 = this._match('[');
      const $$2 = this.parseExpression();
      const $$3 = this.parseRangeDots();
      const $$4 = this.parseExpression();
      const $$5 = this._match(']');
      return [$$3, $$2, $$4];  } finally {
    this.depth--;
  }
}

parseSlice() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseSlice(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IF':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'UNLESS':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'FOR':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'WHILE':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'UNTIL':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'LOOP':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'TRY':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'SWITCH':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'DEF':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'CLASS':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'PARAM_START':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case '->':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case '=>':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case '(':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'UNARY':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'DO':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'UNARY_MATH':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case '-':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case '+':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'AWAIT':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case '--':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case '++':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case '[':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case '{':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'NUMBER':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'JS':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'REGEX':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'REGEX_START':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'UNDEFINED':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'NULL':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'BOOL':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'INFINITY':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'NAN':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'SUPER':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'DYNAMIC_IMPORT':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'DO_IIFE':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'THIS':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case '@':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'NEW_TARGET':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'IMPORT_META':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'IDENTIFIER':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'STRING':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case 'STRING_START':
      {
      const $$1 = this.parseExpression();
      const $$2 = this.parseRangeDots();
      return [$$2, $$1, null];
      }
    case '..':
      {
      const $$1 = this.parseRangeDots();
      return [$$1, null, null];
      }
    case '...':
      {
      const $$1 = this.parseRangeDots();
      return [$$1, null, null];
      }default:      this._error(['IF', 'UNLESS', 'FOR', 'WHILE', 'UNTIL', 'LOOP', 'TRY', 'SWITCH', 'DEF', 'CLASS', 'PARAM_START', '->', '=>', '(', 'UNARY', 'DO', 'UNARY_MATH', '-', '+', 'AWAIT', '--', '++', '[', '{', 'NUMBER', 'JS', 'REGEX', 'REGEX_START', 'UNDEFINED', 'NULL', 'BOOL', 'INFINITY', 'NAN', 'SUPER', 'DYNAMIC_IMPORT', 'DO_IIFE', 'THIS', '@', 'NEW_TARGET', 'IMPORT_META', 'IDENTIFIER', 'STRING', 'STRING_START', '..', '...'], "Invalid Slice");  }
  } finally {
    this.depth--;
  }
}

parseArgList() {
  // Check for INDENT case (multiline)
  if (this.la.kind === 'INDENT') {
    this._match('INDENT');
    const list = this.parseArgList();  // Recursive for multiline
    if (this.la.kind === ',') {
      this._match(',');  // Optional trailing comma
    }
    this._match('OUTDENT');
    return list;
  }

  // Parse first argument
  const list = [];
  list.push(this.parseArg());

  // Parse remaining arguments
  while (this.la.kind === ',' || this.la.kind === 'TERMINATOR') {
    if (this.la.kind === 'TERMINATOR') {
      // Multiline within list (newline-separated args)
      this._match('TERMINATOR');
      if (this.la.kind === 'CALL_END' || this.la.kind === ']') {
        break;  // End of list
      }
      list.push(this.parseArg());
    } else {
      // Comma-separated args
      this._match(',');
      // Check for trailing comma
      if (this.la.kind === 'CALL_END' || this.la.kind === ']' || this.la.kind === 'OUTDENT') {
        break;  // Trailing comma before end
      }
      list.push(this.parseArg());
    }
  }

  return list;
}

parseArgListTail() {
switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      const $$2 = this.parseArg();
      const $$3 = this.parseArgListTail();
      return [$$2, ...$$3];
      }
    case 'TERMINATOR':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('TERMINATOR');
      const $$3 = this.parseArg();
      const $$4 = this.parseArgListTail();
      return [$$3, ...$$4];
      }
    case 'INDENT':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('INDENT');
      const $$3 = this.parseArgList();
      const $$4 = this.parseOptComma();
      const $$5 = this._match('OUTDENT');
      return [...$$3];
      }default:      // ε production
      return [];  }
}

parseArg() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseArg(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IF':
      return this.parseExpression();
    case 'UNLESS':
      return this.parseExpression();
    case 'FOR':
      return this.parseExpression();
    case 'WHILE':
      return this.parseExpression();
    case 'UNTIL':
      return this.parseExpression();
    case 'LOOP':
      return this.parseExpression();
    case 'TRY':
      return this.parseExpression();
    case 'SWITCH':
      return this.parseExpression();
    case 'DEF':
      return this.parseExpression();
    case 'CLASS':
      return this.parseExpression();
    case 'PARAM_START':
      return this.parseExpression();
    case '->':
      return this.parseExpression();
    case '=>':
      return this.parseExpression();
    case '(':
      return this.parseExpression();
    case 'UNARY':
      return this.parseExpression();
    case 'DO':
      return this.parseExpression();
    case 'UNARY_MATH':
      return this.parseExpression();
    case '-':
      return this.parseExpression();
    case '+':
      return this.parseExpression();
    case 'AWAIT':
      return this.parseExpression();
    case '--':
      return this.parseExpression();
    case '++':
      return this.parseExpression();
    case '[':
      return this.parseExpression();
    case '{':
      return this.parseExpression();
    case 'NUMBER':
      return this.parseExpression();
    case 'JS':
      return this.parseExpression();
    case 'REGEX':
      return this.parseExpression();
    case 'REGEX_START':
      return this.parseExpression();
    case 'UNDEFINED':
      return this.parseExpression();
    case 'NULL':
      return this.parseExpression();
    case 'BOOL':
      return this.parseExpression();
    case 'INFINITY':
      return this.parseExpression();
    case 'NAN':
      return this.parseExpression();
    case 'SUPER':
      return this.parseExpression();
    case 'DYNAMIC_IMPORT':
      return this.parseExpression();
    case 'DO_IIFE':
      return this.parseExpression();
    case 'THIS':
      return this.parseExpression();
    case '@':
      return this.parseExpression();
    case 'NEW_TARGET':
      return this.parseExpression();
    case 'IMPORT_META':
      return this.parseExpression();
    case 'IDENTIFIER':
      return this.parseExpression();
    case 'STRING':
      return this.parseExpression();
    case 'STRING_START':
      return this.parseExpression();
    case '...':
      return this.parseSplat();default:
  this._error(['IF', 'UNLESS', 'FOR', 'WHILE', 'UNTIL', 'LOOP', 'TRY', 'SWITCH', 'DEF', 'CLASS', 'PARAM_START', '->', '=>', '(', 'UNARY', 'DO', 'UNARY_MATH', '-', '+', 'AWAIT', '--', '++', '[', '{', 'NUMBER', 'JS', 'REGEX', 'REGEX_START', 'UNDEFINED', 'NULL', 'BOOL', 'INFINITY', 'NAN', 'SUPER', 'DYNAMIC_IMPORT', 'DO_IIFE', 'THIS', '@', 'NEW_TARGET', 'IMPORT_META', 'IDENTIFIER', 'STRING', 'STRING_START', '...'], "Invalid Arg");
  }
  } finally {
    this.depth--;
  }
}

parseArgElisionList() {
  // Check for INDENT case (multiline)
  if (this.la.kind === 'INDENT') {
    this._match('INDENT');
    const list = this.parseArgElisionList();  // Recursive for multiline
    const elisions = this.parseOptElisions();
    this._match('OUTDENT');
    return [...list, ...elisions];
  }

  // Parse first element (may have elisions)
  const list = [];
  const first = this.parseArgElision();
  list.push(...first);

  // Parse remaining elements
  while (this.la.kind === ',' || this.la.kind === 'TERMINATOR') {
    if (this.la.kind === 'TERMINATOR') {
      // Multiline within list
      this._match('TERMINATOR');
      if (this.la.kind === ']' || this.la.kind === 'OUTDENT') {
        break;  // End of list
      }
      const elem = this.parseArgElision();
      list.push(...elem);
    } else {
      // Comma-separated
      this._match(',');
      // Check for trailing comma or end
      if (this.la.kind === ']' || this.la.kind === 'OUTDENT') {
        break;  // Trailing comma before end
      }
      const elem = this.parseArgElision();
      list.push(...elem);
    }
  }

  return list;
}

parseArgElisionListTail() {
switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      const $$2 = this.parseArgElision();
      const $$3 = this.parseArgElisionListTail();
      return [...$$2, ...$$3];
      }
    case 'TERMINATOR':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('TERMINATOR');
      const $$3 = this.parseArgElision();
      const $$4 = this.parseArgElisionListTail();
      return [...$$3, ...$$4];
      }
    case 'INDENT':
      {
      const $$1 = this.parseOptElisions();
      const $$2 = this._match('INDENT');
      const $$3 = this.parseArgElisionList();
      const $$4 = this.parseOptElisions();
      const $$5 = this._match('OUTDENT');
      return [...$$1, ...$$3, ...$$4];
      }default:      // ε production
      return [];  }
}

parseArgElision() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseArgElision(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IF':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'UNLESS':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'FOR':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'TRY':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'SWITCH':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'DEF':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'CLASS':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'PARAM_START':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'UNARY':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'DO':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'UNARY_MATH':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '-':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '+':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'AWAIT':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '--':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '++':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'WHILE':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'UNTIL':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'LOOP':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '->':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '=>':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'JS':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'UNDEFINED':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'NULL':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'BOOL':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'INFINITY':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'NAN':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '(':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '[':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'SUPER':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'DYNAMIC_IMPORT':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'DO_IIFE':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'THIS':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '@':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'NEW_TARGET':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'IMPORT_META':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'IDENTIFIER':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '{':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'NUMBER':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'STRING':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'STRING_START':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'REGEX':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'REGEX_START':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '...':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case ',':
      {
      const $$1 = this.parseElisions();
      const $$2 = this.parseArg();
      return [...$$1, $$2];
      }default:      this._error(['IF', 'UNLESS', 'FOR', 'TRY', 'SWITCH', 'DEF', 'CLASS', 'PARAM_START', 'UNARY', 'DO', 'UNARY_MATH', '-', '+', 'AWAIT', '--', '++', 'WHILE', 'UNTIL', 'LOOP', '->', '=>', 'JS', 'UNDEFINED', 'NULL', 'BOOL', 'INFINITY', 'NAN', '(', '[', 'SUPER', 'DYNAMIC_IMPORT', 'DO_IIFE', 'THIS', '@', 'NEW_TARGET', 'IMPORT_META', 'IDENTIFIER', '{', 'NUMBER', 'STRING', 'STRING_START', 'REGEX', 'REGEX_START', '...', ','], "Invalid ArgElision");  }
  } finally {
    this.depth--;
  }
}

parseOptElisions() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseOptElisions(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      const $$2 = this.parseElisions();
      return [...$$2];
      }default:      this._error([','], "Invalid OptElisions");  }
  } finally {
    this.depth--;
  }
}

parseElisions() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseElisions(). Possible grammar cycle.");
}
try {
// List pattern: Elisions → Elision ElisionsTail
    const $$1 = this.parseElision();
const $$2 = this.parseElisionsTail();
    return [$$1, ...$$2];  } finally {
    this.depth--;
  }
}

parseElisionsTail() {
switch (this.la.kind) {    case ',':
      {
      const $$1 = this.parseElision();
      const $$2 = this.parseElisionsTail();
      return [$$1, ...$$2];
      }default:      // ε production
      return [];  }
}

parseElision() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseElision(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      return null;
      }default:      this._error([','], "Invalid Elision");  }
  } finally {
    this.depth--;
  }
}

parseSimpleArgs() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseSimpleArgs(). Possible grammar cycle.");
}
try {
// List pattern: SimpleArgs → Expression SimpleArgsTail
    const $$1 = this.parseExpression();
const $$2 = this.parseSimpleArgsTail();
    return Array.isArray($$2) && $$2.length > 0 ? [$$1, ...$$2] : [$$1];  } finally {
    this.depth--;
  }
}

parseSimpleArgsTail() {
switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      const $$2 = this.parseExpression();
      const $$3 = this.parseSimpleArgsTail();
      return [$$2, ...$$3];
      }default:      // ε production
      return [];  }
}

parseTry() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseTry(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'TRY':
      {
      const $$1 = this._match('TRY');
      const $$2 = this.parseBlock();
      return ["try", $$2];
      }default:      this._error(['TRY'], "Invalid Try");  }
  } finally {
    this.depth--;
  }
}

parseCatch() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseCatch(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'CATCH':
      {
      const $$1 = this._match('CATCH');
      const $$2 = this.parseBlock();
      return [null, $$2];
      }default:      this._error(['CATCH'], "Invalid Catch");  }
  } finally {
    this.depth--;
  }
}

parseThrow() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseThrow(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'THROW':
      {
      const $$1 = this._match('THROW');
      const $$2 = this.parseExpression();
      return ["throw", $$2];
      }default:      this._error(['THROW'], "Invalid Throw");  }
  } finally {
    this.depth--;
  }
}

parseParenthetical() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseParenthetical(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case '(':
      {
      const $$1 = this._match('(');
      const $$2 = this.parseBody();
      const $$3 = this._match(')');
      return $$2.length === 1 ? $$2[0] : $$2;
      }default:      this._error(['('], "Invalid Parenthetical");  }
  } finally {
    this.depth--;
  }
}

parseWhileSource() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseWhileSource(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'WHILE':
      {
      const $$1 = this._match('WHILE');
      const $$2 = this.parsePrimaryExpression();
      return ["while", $$2];
      }
    case 'UNTIL':
      {
      const $$1 = this._match('UNTIL');
      const $$2 = this.parsePrimaryExpression();
      return ["until", $$2];
      }default:      this._error(['WHILE', 'UNTIL'], "Invalid WhileSource");  }
  } finally {
    this.depth--;
  }
}

parseWhile() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseWhile(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'WHILE':
      {
      const $$1 = this.parseWhileSource();
      const $$2 = this.parseBlock();
      return $$1.length === 2 ? [$$1[0], $$1[1], $$2]   : [$$1[0], $$1[1], $$1[2], $$2];
      }
    case 'UNTIL':
      {
      const $$1 = this.parseWhileSource();
      const $$2 = this.parseBlock();
      return $$1.length === 2 ? [$$1[0], $$1[1], $$2]   : [$$1[0], $$1[1], $$1[2], $$2];
      }
    case 'LOOP':
      {
      const $$1 = this.parseLoop();
      return $$1;
      }default:      this._error(['WHILE', 'UNTIL', 'LOOP'], "Invalid While");  }
  } finally {
    this.depth--;
  }
}

parseLoop() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseLoop(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'LOOP':
      {
      const $$1 = this._match('LOOP');
      const $$2 = this.parseBlock();
      return ["loop", $$2];
      }default:      this._error(['LOOP'], "Invalid Loop");  }
  } finally {
    this.depth--;
  }
}

parseFor() {
  // Check if it starts with FOR keyword
  if (this.la.kind === 'FOR') {
    this._match('FOR');
    
    // Check for AWAIT (FOR AWAIT ForVariables FORFROM...)
    let hasAwait = false;
    if (this.la.kind === 'AWAIT') {
      this._match('AWAIT');
      hasAwait = true;
    }
    
    // Check for OWN (FOR OWN ForVariables FOROF...)
    let hasOwn = false;
    if (this.la.kind === 'OWN') {
      this._match('OWN');
      hasOwn = true;
    }
    
    // Check what comes next: ForVariables or Range
    if (this.la.kind === '[') {
      // FOR Range Block (simple range-based loop)
      const range = this.parseRange();
      
      // Optional BY
      let byExpr = null;
      if (this.la.kind === 'BY') {
        this._match('BY');
        byExpr = this.parseExpression();
      }
      
      const block = this.parseBlock();
      return ["for-in", [], range, byExpr, null, block];
    } else {
      // FOR ForVariables FORIN/FOROF/FORFROM Expression
      const vars = this.parseForVariables();
      
      // Check loop type
      if (this.la.kind === 'FORIN') {
        this._match('FORIN');
        const expr = this.parseExpression();
        
        // Optional BY
        let byExpr = null;
        if (this.la.kind === 'BY') {
          this._match('BY');
          byExpr = this.parseExpression();
        }
        
        // Optional WHEN
        let whenExpr = null;
        if (this.la.kind === 'WHEN') {
          this._match('WHEN');
          whenExpr = this.parseExpression();
        }
        
        const block = this.parseBlock();
        return ["for-in", vars, expr, byExpr, whenExpr, block];
      } else if (this.la.kind === 'FOROF') {
        this._match('FOROF');
        const expr = this.parseExpression();
        
        // Optional WHEN
        let whenExpr = null;
        if (this.la.kind === 'WHEN') {
          this._match('WHEN');
          whenExpr = this.parseExpression();
        }
        
        const block = this.parseBlock();
        return ["for-of", vars, expr, hasOwn, whenExpr, block];
      } else if (this.la.kind === 'FORFROM') {
        this._match('FORFROM');
        const expr = this.parseExpression();
        
        // Optional WHEN
        let whenExpr = null;
        if (this.la.kind === 'WHEN') {
          this._match('WHEN');
          whenExpr = this.parseExpression();
        }
        
        const block = this.parseBlock();
        return ["for-from", vars, expr, hasAwait, whenExpr, block];
      } else {
        this._error(['FORIN', 'FOROF', 'FORFROM'], "Expected for loop type");
      }
    }
  } else {
    // Comprehension form: Expression FOR Range
    const expr = this.parseExpression();
    this._match('FOR');
    const range = this.parseRange();
    return ["comprehension", expr, [["for-in", [], range, null]], []];
  }
}

parseForValue() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseForValue(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IDENTIFIER':
      {
      const $$1 = this.parseForVar();
      return $$1;
      }
    case '@':
      {
      const $$1 = this.parseForVar();
      return $$1;
      }
    case '[':
      {
      const $$1 = this.parseForVar();
      return $$1;
      }
    case '{':
      {
      const $$1 = this.parseForVar();
      return $$1;
      }default:      this._error(['IDENTIFIER', '@', '[', '{'], "Invalid ForValue");  }
  } finally {
    this.depth--;
  }
}

parseForVar() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseForVar(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IDENTIFIER':
      return this.parseIdentifier();
    case '@':
      return this.parseThisProperty();
    case '[':
      return this.parseArray();
    case '{':
      return this.parseObject();default:
  this._error(['IDENTIFIER', '@', '[', '{'], "Invalid ForVar");
  }
  } finally {
    this.depth--;
  }
}

parseForVariables() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseForVariables(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IDENTIFIER':
      {
      const $$1 = this.parseForValue();
      return [$$1];
      }
    case '@':
      {
      const $$1 = this.parseForValue();
      return [$$1];
      }
    case '[':
      {
      const $$1 = this.parseForValue();
      return [$$1];
      }
    case '{':
      {
      const $$1 = this.parseForValue();
      return [$$1];
      }default:      this._error(['IDENTIFIER', '@', '[', '{'], "Invalid ForVariables");  }
  } finally {
    this.depth--;
  }
}

parseSwitch() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseSwitch(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'SWITCH':
      {
      const $$1 = this._match('SWITCH');
      const $$2 = this._match('INDENT');
      const $$3 = this.parseWhens();
      const $$4 = this._match('OUTDENT');
      return ["switch", null, $$3, null];
      }default:      this._error(['SWITCH'], "Invalid Switch");  }
  } finally {
    this.depth--;
  }
}

parseWhens() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseWhens(). Possible grammar cycle.");
}
try {
// List pattern: Whens → When WhensTail
    const $$1 = this.parseWhen();
const $$2 = this.parseWhensTail();
    return [$$1, ...$$2];  } finally {
    this.depth--;
  }
}

parseWhensTail() {
switch (this.la.kind) {    case 'LEADING_WHEN':
      {
      const $$1 = this.parseWhen();
      const $$2 = this.parseWhensTail();
      return [$$1, ...$$2];
      }default:      // ε production
      return [];  }
}

parseWhen() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseWhen(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'LEADING_WHEN':
      {
      const $$1 = this._match('LEADING_WHEN');
      const $$2 = this.parseSimpleArgs();
      const $$3 = this.parseBlock();
      return ["when", $$2, $$3];
      }default:      this._error(['LEADING_WHEN'], "Invalid When");  }
  } finally {
    this.depth--;
  }
}

parseIfBlock() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseIfBlock(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'IF':
      {
      const $$1 = this._match('IF');
      const $$2 = this.parseOperation();
      const $$3 = this.parseBlock();
      return ["if", $$2, $$3];
      }default:      this._error(['IF'], "Invalid IfBlock");  }
  } finally {
    this.depth--;
  }
}

parseUnlessBlock() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseUnlessBlock(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'UNLESS':
      {
      const $$1 = this._match('UNLESS');
      const $$2 = this.parseOperation();
      const $$3 = this.parseBlock();
      return ["unless", $$2, $$3];
      }default:      this._error(['UNLESS'], "Invalid UnlessBlock");  }
  } finally {
    this.depth--;
  }
}

parseIf() {
  // Parse IfBlock or UnlessBlock
  let result;
  if (this.la.kind === 'IF') {
    result = this.parseIfBlock();
  } else if (this.la.kind === 'UNLESS') {
    result = this.parseUnlessBlock();
  } else {
    this._error(['IF', 'UNLESS'], "Invalid If");
  }

  // Check for ELSE continuation
  if (this.la.kind === 'ELSE') {
    this._match('ELSE');
    const elseBlock = this.parseBlock();
    // Append else block to if: result.length === 3 ? ["if", result[1], result[2], elseBlock] : [...result, elseBlock]
    if (result.length === 3) {
      return ["if", result[1], result[2], elseBlock];
    } else {
      return [...result, elseBlock];
    }
  }

  return result;
}

parseOperationLine() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseOperationLine(). Possible grammar cycle.");
}
try {
switch (this.la.kind) {    case 'UNARY':
      {
      const $$1 = this._match('UNARY');
      const $$2 = this.parseExpressionLine();
      return [$$1, $$2];
      }
    case 'DO':
      {
      const $$1 = this._match('DO');
      const $$2 = this.parseExpressionLine();
      return ["do-iife", $$2];
      }
    case 'DO_IIFE':
      {
      const $$1 = this._match('DO_IIFE');
      const $$2 = this.parseCodeLine();
      return ["do-iife", $$2];
      }default:      this._error(['UNARY', 'DO', 'DO_IIFE'], "Invalid OperationLine");  }
  } finally {
    this.depth--;
  }
}

parseOperation() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseOperation(). Possible grammar cycle.");
}
try {
// Binary operator iteration (FULL IMPLEMENTATION!)
let left;

// Parse base expression
switch (this.la.kind) {    case 'IDENTIFIER':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case '@':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'JS':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'UNDEFINED':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'NULL':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'BOOL':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'INFINITY':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'NAN':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case '(':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case '[':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'SUPER':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'DYNAMIC_IMPORT':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'DO_IIFE':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'THIS':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'NEW_TARGET':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'IMPORT_META':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'PARAM_START':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case '->':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case '=>':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case '{':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'NUMBER':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'STRING':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'STRING_START':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'REGEX':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'REGEX_START':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'UNARY':
      {
      const $$1 = this._match('UNARY');
      const $$2 = this.parseValue();
      left = [$$1, $$2];;
      break;
      }
    case 'DO':
      {
      const $$1 = this._match('DO');
      const $$2 = this.parseValue();
      left = ["do-iife", $$2];;
      break;
      }
    case 'UNARY_MATH':
      {
      const $$1 = this._match('UNARY_MATH');
      const $$2 = this.parseValue();
      left = [$$1, $$2];;
      break;
      }
    case '-':
      {
      const $$1 = this._match('-');
      const $$2 = this.parseValue();
      left = ["-", $$2];;
      break;
      }
    case '+':
      {
      const $$1 = this._match('+');
      const $$2 = this.parseValue();
      left = ["+", $$2];;
      break;
      }
    case 'AWAIT':
      {
      const $$1 = this._match('AWAIT');
      const $$2 = this.parseValue();
      left = ["await", $$2];;
      break;
      }
    case '--':
      {
      const $$1 = this._match('--');
      const $$2 = this.parseSimpleAssignable();
      left = ["--", $$2, false];;
      break;
      }
    case '++':
      {
      const $$1 = this._match('++');
      const $$2 = this.parseSimpleAssignable();
      left = ["++", $$2, false];;
      break;
      }default:
  this._error([], "Invalid Operation");
}

// Iterate through binary operators
while (true) {
  switch (this.la.kind) {      case '=': {
        this._match('=');
        const right = this.parseExpression();
        const [$$1, $$2, $$3] = [left, '=', right];
        left = ["=", left, right];
        break;
      }
      case '+': {
        this._match('+');
        const right = this.parseValue();
        const [$$1, $$2, $$3] = [left, '+', right];
        left = ["+", left, right];
        break;
      }
      case '-': {
        this._match('-');
        const right = this.parseValue();
        const [$$1, $$2, $$3] = [left, '-', right];
        left = ["-", left, right];
        break;
      }
      case 'MATH': {
        const op = this._match('MATH');
        const right = this.parseValue();
        const [$$1, $$2, $$3] = [left, op, right];
        left = [op, left, right];
        break;
      }
      case '**': {
        this._match('**');
        const right = this.parseValue();
        const [$$1, $$2, $$3] = [left, '**', right];
        left = ["**", left, right];
        break;
      }
      case 'SHIFT': {
        const op = this._match('SHIFT');
        const right = this.parseValue();
        const [$$1, $$2, $$3] = [left, op, right];
        left = [op, left, right];
        break;
      }
      case 'COMPARE': {
        const op = this._match('COMPARE');
        const right = this.parseValue();
        const [$$1, $$2, $$3] = [left, op, right];
        left = [op, left, right];
        break;
      }
      case '&': {
        this._match('&');
        const right = this.parseValue();
        const [$$1, $$2, $$3] = [left, '&', right];
        left = ["&", left, right];
        break;
      }
      case '^': {
        this._match('^');
        const right = this.parseValue();
        const [$$1, $$2, $$3] = [left, '^', right];
        left = ["^", left, right];
        break;
      }
      case '|': {
        this._match('|');
        const right = this.parseValue();
        const [$$1, $$2, $$3] = [left, '|', right];
        left = ["|", left, right];
        break;
      }
      case '&&': {
        this._match('&&');
        const right = this.parseValue();
        const [$$1, $$2, $$3] = [left, '&&', right];
        left = ["&&", left, right];
        break;
      }
      case '||': {
        this._match('||');
        const right = this.parseValue();
        const [$$1, $$2, $$3] = [left, '||', right];
        left = ["||", left, right];
        break;
      }
      case '??': {
        this._match('??');
        const right = this.parseValue();
        const [$$1, $$2, $$3] = [left, '??', right];
        left = ["??", left, right];
        break;
      }
      case '!?': {
        this._match('!?');
        const right = this.parseValue();
        const [$$1, $$2, $$3] = [left, '!?', right];
        left = ["!?", left, right];
        break;
      }
      case 'RELATION': {
        const op = this._match('RELATION');
        const right = this.parseValue();
        const [$$1, $$2, $$3] = [left, op, right];
        left = [op, left, right];
        break;
      }
      case 'COMPOUND_ASSIGN': {
        const op = this._match('COMPOUND_ASSIGN');
        const right = this.parseExpression();
        const [$$1, $$2, $$3] = [left, op, right];
        left = [op, left, right];
        break;
      }
      case '--': {
        this._match('--');
        const [$$1, $$2] = [left, '--'];
        left = ["--", left, true];
        break;
      }
      case '++': {
        this._match('++');
        const [$$1, $$2] = [left, '++'];
        left = ["++", left, true];
        break;
      }      default:
        return left;
    }
  }
  } finally {
    this.depth--;
  }
}

parseDoIife() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parseDoIife(). Possible grammar cycle.");
}
try {
    const $$1 = this._match('DO_IIFE');
      const $$2 = this.parseCode();
      return ["do-iife", $$2];  } finally {
    this.depth--;
  }
}

parse$accept() {
// Recursion depth tracking
this.depth++;
if (this.depth > this.maxDepth) {
  this.depth--;
  this._error([], "Maximum recursion depth (" + this.maxDepth + ") exceeded in parse$accept(). Possible grammar cycle.");
}
try {
    const $$1 = this.parseRoot();
      const $$2 = this._match('$end');
      return [$$1, $$2];  } finally {
    this.depth--;
  }
}}

const parser = new Parser();

export { parser, Parser };
export const parse = parser.parse.bind(parser);
export default parser;