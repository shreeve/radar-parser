// Predictive Recursive Descent Parser generated by Solar 1.4.0 (RD mode)

class Parser {
  constructor() {
    this.la = null;        // Current lookahead token
    this.lexer = null;     // Lexer instance
    this.yy = {};          // Shared state
  }

  // Initialize parser with input
  parse(input) {
    this.lexer = this._createLexer();
    this.lexer.setInput(input, this.yy);
    this.la = this._nextToken();
    const result = this.parseRoot();
  if (this.la.kind !== '$end') {
    this._error(['$end'], 'Expected end of input');
  }
  return result;
}

// Get next token from lexer
_nextToken() {
  const tok = this.lexer.lex() || '$end';
  const kind = typeof tok === 'number' ? this._tokenName(tok) : tok;
  return {
    kind: kind,
    value: this.lexer.yytext,
    line: this.lexer.yylineno,
    column: this.lexer.yylloc?.first_column || 0
  };
}

// Match expected token and advance
_match(kind) {
  if (this.la.kind !== kind) {
    this._error([kind], `Expected ${kind}`);
  }
  const value = this.la.value;  // Cache value before overwriting la
  this.la = this._nextToken();
  return value;
}

// Check if current token is in set
_check(...kinds) {
  return kinds.includes(this.la.kind);
}

// Error handling
_error(expected, msg) {
  const line = this.la.line + 1;
  const col = this.la.column;
  const token = this.la.kind;
  throw new Error(
    `Parse error at line ${line}, column ${col}: ${msg}\n` +
    `Got '${token}', expected one of: ${expected.join(', ')}`
  );
}

// Token name lookup
_tokenName(id) {
  const names = {"2":"error","7":"TERMINATOR","12":"STATEMENT","27":"DEF","29":"CALL_START","31":"CALL_END","35":"YIELD","36":"INDENT","38":"OUTDENT","39":"FROM","40":"IDENTIFIER","42":"PROPERTY","44":"NUMBER","46":"STRING","47":"STRING_START","49":"STRING_END","52":"INTERPOLATION_START","53":"INTERPOLATION_END","55":"REGEX","56":"REGEX_START","58":"REGEX_END","60":",","62":"JS","63":"UNDEFINED","64":"NULL","65":"BOOL","66":"INFINITY","67":"NAN","70":"=","74":":","77":"[","78":"]","79":"@","80":"...","85":"SUPER","87":"DYNAMIC_IMPORT","89":".","90":"?.","91":"::","92":"?::","93":"INDEX_START","94":"INDEX_END","95":"INDEX_SOAK","96":"RETURN","97":"PARAM_START","98":"PARAM_END","100":"->","101":"=>","111":"ES6_OPTIONAL_INDEX","115":"NEW_TARGET","116":"IMPORT_META","117":"{","118":"FOR","120":"FOROF","121":"}","122":"WHEN","123":"OWN","126":"CLASS","127":"EXTENDS","128":"IMPORT","134":"AS","135":"DEFAULT","136":"IMPORT_ALL","137":"EXPORT","139":"EXPORT_ALL","142":"ES6_OPTIONAL_CALL","143":"FUNC_EXIST","145":"THIS","150":"..","159":"TRY","161":"FINALLY","162":"CATCH","163":"THROW","164":"(","165":")","167":"WHILE","168":"UNTIL","170":"LOOP","171":"FORIN","172":"BY","173":"FORFROM","174":"AWAIT","177":"SWITCH","179":"ELSE","182":"LEADING_WHEN","184":"IF","186":"UNLESS","187":"UNARY","188":"DO","189":"DO_IIFE","190":"UNARY_MATH","191":"-","192":"+","193":"--","194":"++","195":"?","196":"MATH","197":"**","198":"SHIFT","199":"COMPARE","200":"&","201":"^","202":"|","203":"&&","204":"||","205":"??","206":"!?","207":"RELATION","208":"SPACE?","209":"POST_IF","210":"POST_UNLESS","211":"COMPOUND_ASSIGN"};
    return names[id] || id;
  }

  // Create lexer (stub - override with actual lexer)
  _createLexer() {
    if (this.lexer) return this.lexer;
    throw new Error('No lexer provided. Set parser.lexer before calling parse()');
  }

  // ========================================================================
  // Parse Functions (one per nonterminal)
  // ========================================================================
  parseRoot() {
    // Root: prefer Body over ε unless at EOF
    if (this.la.kind !== '$end') {
      const $$1 = this.parseBody();
      return ["program", ...$$1];
    }
    // ε production (empty program)
    return ["program"];
  }

  parseBody() {
    // List pattern: Body → Line BodyTail
    const $$1 = this.parseLine();
    const $$2 = this.parseBodyTail();
    return [$$1, ...$$2];
  }

  parseBodyTail() {
    if (this.la.kind === 'TERMINATOR') {
      this._match('TERMINATOR');
      // Check if next token can start Line
      if (['IF', 'UNLESS', 'FOR', 'WHILE', 'UNTIL', 'LOOP', 'TRY', 'SWITCH', 'DEF', 'CLASS', 'PARAM_START', '->', '=>', 'YIELD', 'THROW', 'IDENTIFIER', '@', 'JS', 'UNDEFINED', 'NULL', 'BOOL', 'INFINITY', 'NAN', '(', '[', 'SUPER', 'DYNAMIC_IMPORT', 'DO_IIFE', 'THIS', 'NEW_TARGET', 'IMPORT_META', '{', 'NUMBER', 'STRING', 'STRING_START', 'REGEX', 'REGEX_START', 'UNARY', 'DO', 'UNARY_MATH', '-', '+', 'AWAIT', '--', '++', 'RETURN', 'STATEMENT', 'IMPORT', 'EXPORT'].includes(this.la.kind)) {
        // Rule: TERMINATOR Line BodyTail
        const elem = this.parseLine();
        const tail = this.parseBodyTail();
        return [elem, ...tail];
      } else {
        // Rule: TERMINATOR BodyTail (skip separator, continue)
        const tail = this.parseBodyTail();
        return [...tail];
      }
    } else {
      // ε production
      return [];
    }
  }


parseLine() {
    switch (this.la.kind) {    case 'IF': return this.parseExpression();
    case 'UNLESS': return this.parseExpression();
    case 'FOR': return this.parseExpression();
    case 'WHILE': return this.parseExpression();
    case 'UNTIL': return this.parseExpression();
    case 'LOOP': return this.parseExpression();
    case 'TRY': return this.parseExpression();
    case 'SWITCH': return this.parseExpression();
    case 'DEF': return this.parseExpression();
    case 'CLASS': return this.parseExpression();
    case 'PARAM_START': return this.parseExpression();
    case '->': return this.parseExpression();
    case '=>': return this.parseExpression();
    case 'YIELD': return this.parseExpression();
    case 'THROW': return this.parseExpression();
    case 'IDENTIFIER': return this.parseExpression();
    case '@': return this.parseExpression();
    case '[': return this.parseExpression();
    case '{': return this.parseExpression();
    case 'NUMBER': return this.parseExpression();
    case 'JS': return this.parseExpression();
    case 'REGEX': return this.parseExpression();
    case 'REGEX_START': return this.parseExpression();
    case 'UNDEFINED': return this.parseExpression();
    case 'NULL': return this.parseExpression();
    case 'BOOL': return this.parseExpression();
    case 'INFINITY': return this.parseExpression();
    case 'NAN': return this.parseExpression();
    case '(': return this.parseExpression();
    case 'SUPER': return this.parseExpression();
    case 'DYNAMIC_IMPORT': return this.parseExpression();
    case 'DO_IIFE': return this.parseExpression();
    case 'THIS': return this.parseExpression();
    case 'NEW_TARGET': return this.parseExpression();
    case 'IMPORT_META': return this.parseExpression();
    case 'STRING': return this.parseExpression();
    case 'STRING_START': return this.parseExpression();
    case 'UNARY': return this.parseExpression();
    case 'DO': return this.parseExpression();
    case 'UNARY_MATH': return this.parseExpression();
    case '-': return this.parseExpression();
    case '+': return this.parseExpression();
    case 'AWAIT': return this.parseExpression();
    case '--': return this.parseExpression();
    case '++': return this.parseExpression();
    case 'RETURN': return this.parseStatement();
    case 'STATEMENT': return this.parseStatement();
    case 'IMPORT': return this.parseStatement();
    case 'EXPORT': return this.parseStatement();default:
  this._error(['IF', 'UNLESS', 'FOR', 'WHILE', 'UNTIL', 'LOOP', 'TRY', 'SWITCH', 'DEF', 'CLASS', 'PARAM_START', '->', '=>', 'YIELD', 'THROW', 'IDENTIFIER', '@', '[', '{', 'NUMBER', 'JS', 'REGEX', 'REGEX_START', 'UNDEFINED', 'NULL', 'BOOL', 'INFINITY', 'NAN', '(', 'SUPER', 'DYNAMIC_IMPORT', 'DO_IIFE', 'THIS', 'NEW_TARGET', 'IMPORT_META', 'STRING', 'STRING_START', 'UNARY', 'DO', 'UNARY_MATH', '-', '+', 'AWAIT', '--', '++', 'RETURN', 'STATEMENT', 'IMPORT', 'EXPORT'], "Invalid Line");
    }
  }

  parseStatement() {
    switch (this.la.kind) {
      case 'RETURN': {
        const returnStmt = this.parseReturn();

        // Check for postfix conditionals (return x if y, return unless z)
        if (this.la.kind === 'POST_IF') {
          this._match('POST_IF');
          const condition = this.parseOperation();
          return ["if", condition, [returnStmt]];
        } else if (this.la.kind === 'POST_UNLESS') {
          this._match('POST_UNLESS');
          const condition = this.parseOperation();
          return ["unless", condition, [returnStmt]];
        }

        return returnStmt;
      }
      case 'STATEMENT': {
        const stmt = this._match('STATEMENT');

        // Check for postfix conditionals (break if x, continue unless y)
        if (this.la.kind === 'POST_IF') {
          this._match('POST_IF');
          const condition = this.parseOperation();
          return ["if", condition, [stmt]];
        } else if (this.la.kind === 'POST_UNLESS') {
          this._match('POST_UNLESS');
          const condition = this.parseOperation();
          return ["unless", condition, [stmt]];
        }

        // No postfix conditional - just return the statement
        return stmt;
      }
      case 'IMPORT':
        return this.parseImport();
      case 'EXPORT':
        return this.parseExport();
      default:
        this._error(['RETURN', 'STATEMENT', 'IMPORT', 'EXPORT'], "Invalid Statement");
    }
  }

  parseExpression() {
    switch (this.la.kind) {
      case 'IF':
      case 'UNLESS':
        return this.parseIf();
      case 'FOR':
        return this.parseFor();
      case 'WHILE':
      case 'UNTIL':
      case 'LOOP':
        return this.parseWhile();
      case 'TRY':
        return this.parseTry();
      case 'SWITCH':
        return this.parseSwitch();
      case 'DEF':
        return this.parseDef();
      case 'CLASS':
        return this.parseClass();
      case 'PARAM_START':
      case '->':
      case '=>':
        return this.parseCode();
      case 'YIELD':
        return this.parseYield();
      case 'THROW':
        return this.parseThrow();
      default:
        return this.parseOperation();
    }
  }

parsePrimaryExpression() {const $$1 = this.parseOperation();
      return $$1;  }

  parseDef() {
    // Parse common prefix
    const $$1 = this._match('DEF');
    const $$2 = this.parseIdentifier();

    // Lookahead to decide which alternative
    if (this.la.kind === 'CALL_START') {
      // With params: DEF Identifier CALL_START ParamList CALL_END Block
      const $$3 = this._match('CALL_START');
      const $$4 = this.parseParamList();
      const $$5 = this._match('CALL_END');
      const $$6 = this.parseBlock();
      return ["def", $$2, $$4, $$6];
    } else {
      // No params: DEF Identifier Block
      const $$3 = this.parseBlock();
      return ["def", $$2, [], $$3];
    }
  }

parseExpressionLine() {
    switch (this.la.kind) {    case 'PARAM_START':
      {
      const $$1 = this.parseCodeLine();
      return $$1;
      }
    case '->':
      {
      const $$1 = this.parseCodeLine();
      return $$1;
      }
    case '=>':
      {
      const $$1 = this.parseCodeLine();
      return $$1;
      }
    case 'UNARY':
      {
      const $$1 = this.parseOperationLine();
      return $$1;
      }
    case 'DO':
      {
      const $$1 = this.parseOperationLine();
      return $$1;
      }
    case 'DO_IIFE':
      {
      const $$1 = this.parseOperationLine();
      return $$1;
      }      default:      this._error(['PARAM_START', '->', '=>', 'UNARY', 'DO', 'DO_IIFE'], "Invalid ExpressionLine");    }
  }

  parseYield() {
    this._match('YIELD');

    // Check for FROM (yield from)
    if (this.la.kind === 'FROM') {
      this._match('FROM');
      const expr = this.parseExpression();
      return ["yield-from", expr];
    }

    // Check for indented object
    if (this.la.kind === 'INDENT') {
      this._match('INDENT');
      const obj = this.parseObject();
      this._match('OUTDENT');
      return ["yield", obj];
    }

    // Check if there's an expression
    if (this.la.kind !== 'TERMINATOR' && this.la.kind !== 'OUTDENT' &&
        this.la.kind !== '$end' && this.la.kind !== null) {
      const expr = this.parseExpression();
      return ["yield", expr];
    }

    // No expression - just yield
    return ["yield"];
  }

  parseBlock() {
    // Parse INDENT
    const $$1 = this._match('INDENT');

    // Lookahead to decide which alternative
    if (this.la.kind === 'OUTDENT') {
      // Empty block: INDENT OUTDENT
      const $$2 = this._match('OUTDENT');
      return ["block"];
    } else {
      // Block with body: INDENT Body OUTDENT
      const $$2 = this.parseBody();
      const $$3 = this._match('OUTDENT');
      return ["block", ...$$2];
    }
  }

parseIdentifier() {const $$1 = this._match('IDENTIFIER');
      return $$1;  }

parseProperty() {const $$1 = this._match('PROPERTY');
      return $$1;  }

parseAlphaNumeric() {
    switch (this.la.kind) {    case 'NUMBER':
      {
      const $$1 = this._match('NUMBER');
      return $$1;
      }
    case 'STRING':
      {
      const $$1 = this.parseString();
      return $$1;
      }
    case 'STRING_START':
      {
      const $$1 = this.parseString();
      return $$1;
      }      default:      this._error(['NUMBER', 'STRING', 'STRING_START'], "Invalid AlphaNumeric");    }
  }

parseString() {
    switch (this.la.kind) {    case 'STRING':
      {
      const $$1 = this._match('STRING');
      return $$1;
      }
    case 'STRING_START':
      {
      const $$1 = this._match('STRING_START');
      const $$2 = this.parseInterpolations();
      const $$3 = this._match('STRING_END');
      return ["str", ...$$2];
      }      default:      this._error(['STRING', 'STRING_START'], "Invalid String");    }
  }

  parseInterpolations() {
    // List pattern: Interpolations → InterpolationChunk InterpolationsTail
    const $$1 = this.parseInterpolationChunk();
    const $$2 = this.parseInterpolationsTail();
    return [$$1, ...$$2];
  }

parseInterpolationsTail() {
    switch (this.la.kind) {    case 'INTERPOLATION_START':
      {
      const $$1 = this.parseInterpolationChunk();
      const $$2 = this.parseInterpolationsTail();
      return [$$1, ...$$2];
      }
    case 'STRING':
      {
      const $$1 = this.parseInterpolationChunk();
      const $$2 = this.parseInterpolationsTail();
      return [$$1, ...$$2];
      }
    case 'STRING_START':
      {
      const $$1 = this.parseInterpolationChunk();
      const $$2 = this.parseInterpolationsTail();
      return [$$1, ...$$2];
      }      default:      // ε production
      return [];    }
  }

  parseInterpolationChunk() {
    // Check if it's a String
    if (this.la.kind === 'STRING' || this.la.kind === 'STRING_START') {
      return this.parseString();
    }

    // Otherwise must be INTERPOLATION_START
    if (this.la.kind === 'INTERPOLATION_START') {
      this._match('INTERPOLATION_START');

      // Check if empty interpolation (INTERPOLATION_END immediately)
      if (this.la.kind === 'INTERPOLATION_END') {
        this._match('INTERPOLATION_END');
        return "";
      }

      // Check if indented body
      if (this.la.kind === 'INDENT') {
        this._match('INDENT');
        const body = this.parseBody();
        this._match('OUTDENT');
        this._match('INTERPOLATION_END');
        return body;
      }

      // Otherwise parse Body directly
      const body = this.parseBody();
      this._match('INTERPOLATION_END');
      return body;
    }

    this._error(['INTERPOLATION_START', 'STRING', 'STRING_START'], "Invalid InterpolationChunk");
  }

parseRegex() {
    switch (this.la.kind) {    case 'REGEX':
      {
      const $$1 = this._match('REGEX');
      return $$1;
      }
    case 'REGEX_START':
      {
      const $$1 = this._match('REGEX_START');
      const $$2 = this.parseInvocation();
      const $$3 = this._match('REGEX_END');
      return ["regex", $$2];
      }      default:      this._error(['REGEX', 'REGEX_START'], "Invalid Regex");    }
  }

parseRegexWithIndex() {
    switch (this.la.kind) {    case 'REGEX':
      {
      const $$1 = this.parseRegex();
      return ["regex-index", $$1, null];
      }
    case 'REGEX_START':
      {
      const $$1 = this.parseRegex();
      return ["regex-index", $$1, null];
      }      default:      this._error(['REGEX', 'REGEX_START'], "Invalid RegexWithIndex");    }
  }

parseLiteral() {
    switch (this.la.kind) {    case 'NUMBER':
      {
      const $$1 = this.parseAlphaNumeric();
      return $$1;
      }
    case 'STRING':
      {
      const $$1 = this.parseAlphaNumeric();
      return $$1;
      }
    case 'STRING_START':
      {
      const $$1 = this.parseAlphaNumeric();
      return $$1;
      }
    case 'JS':
      {
      const $$1 = this._match('JS');
      return $$1;
      }
    case 'REGEX':
      {
      const $$1 = this.parseRegex();
      return $$1;
      }
    case 'REGEX_START':
      {
      const $$1 = this.parseRegex();
      return $$1;
      }
    case 'UNDEFINED':
      {
      const $$1 = this._match('UNDEFINED');
      return "undefined";
      }
    case 'NULL':
      {
      const $$1 = this._match('NULL');
      return "null";
      }
    case 'BOOL':
      {
      const $$1 = this._match('BOOL');
      return $$1;
      }
    case 'INFINITY':
      {
      const $$1 = this._match('INFINITY');
      return $$1;
      }
    case 'NAN':
      {
      const $$1 = this._match('NAN');
      return $$1;
      }      default:      this._error(['NUMBER', 'STRING', 'STRING_START', 'JS', 'REGEX', 'REGEX_START', 'UNDEFINED', 'NULL', 'BOOL', 'INFINITY', 'NAN'], "Invalid Literal");    }
  }

  parseAssign() {
    // Parse Assignable
    const lhs = this.parseAssignable();

    // Match = token
    this._match('=');

    // Check for optional TERMINATOR or INDENT
    if (this.la.kind === 'TERMINATOR') {
      this._match('TERMINATOR');
      const rhs = this.parseExpression();
      return ["=", lhs, rhs];
    } else if (this.la.kind === 'INDENT') {
      this._match('INDENT');
      const rhs = this.parseExpression();
      this._match('OUTDENT');
      return ["=", lhs, rhs];
    } else {
      // Simple assignment: Assignable = Expression
      const rhs = this.parseExpression();
      return ["=", lhs, rhs];
    }
  }

  parseAssignObj() {
    // Check for rest spread: {...rest}
    if (this.la.kind === '...') {
      return this.parseObjRestValue();
    }

    // Parse the key (ObjAssignable or SimpleObjAssignable)
    let key;
    if (this.la.kind === 'IDENTIFIER' || this.la.kind === 'PROPERTY' || this.la.kind === '@' ||
        this.la.kind === '[' || this.la.kind === 'NUMBER' || this.la.kind === 'STRING' || this.la.kind === 'STRING_START') {

      // For default values, we need SimpleObjAssignable
      if (this.la.kind === 'IDENTIFIER' || this.la.kind === 'PROPERTY' || this.la.kind === '@') {
        key = this.parseSimpleObjAssignable();
      } else {
        key = this.parseObjAssignable();
      }

      // Check what follows the key
      if (this.la.kind === ':') {
        // Property with value: {a: 1}
        this._match(':');
        if (this.la.kind === 'INDENT') {
          this._match('INDENT');
          const value = this.parseExpression();
          this._match('OUTDENT');
          return [key, value, ":"];
        } else {
          const value = this.parseExpression();
          return [key, value, ":"];
        }
      } else if (this.la.kind === '=') {
        // Default value: {a = 5}
        this._match('=');
        if (this.la.kind === 'INDENT') {
          this._match('INDENT');
          const value = this.parseExpression();
          this._match('OUTDENT');
          return [key, value, "="];
        } else {
          const value = this.parseExpression();
          return [key, value, "="];
        }
      } else {
        // Property shorthand: {x}
        return [key, key, null];
      }
    }

    this._error([], "Invalid AssignObj");
  }

parseSimpleObjAssignable() {
    switch (this.la.kind) {    case 'IDENTIFIER': return this.parseIdentifier();
    case 'PROPERTY': return this.parseProperty();
    case '@': return this.parseThisProperty();default:
  this._error(['IDENTIFIER', 'PROPERTY', '@'], "Invalid SimpleObjAssignable");
    }
  }

parseObjAssignable() {
    switch (this.la.kind) {    case 'IDENTIFIER': return this.parseSimpleObjAssignable();
    case 'PROPERTY': return this.parseSimpleObjAssignable();
    case '@': return this.parseSimpleObjAssignable();
    case '[':
      {
      const $$1 = this._match('[');
      const $$2 = this.parseExpression();
      const $$3 = this._match(']');
      return ["computed", $$2];
      }
    case 'NUMBER': return this.parseAlphaNumeric();
    case 'STRING': return this.parseAlphaNumeric();
    case 'STRING_START': return this.parseAlphaNumeric();default:
  this._error(['IDENTIFIER', 'PROPERTY', '@', '[', 'NUMBER', 'STRING', 'STRING_START'], "Invalid ObjAssignable");
    }
  }

parseObjRestValue() {
    switch (this.la.kind) {    case '...':
      {
      const $$1 = this._match('...');
      const $$2 = this.parseSimpleObjAssignable();
      return ["...", $$2];
      }      default:      this._error(['...'], "Invalid ObjRestValue");    }
  }

parseObjSpreadExpr() {
    switch (this.la.kind) {    case 'IDENTIFIER':
      {
      const $$1 = this.parseSimpleObjAssignable();
      return $$1;
      }
    case 'PROPERTY':
      {
      const $$1 = this.parseSimpleObjAssignable();
      return $$1;
      }
    case '@':
      {
      const $$1 = this.parseSimpleObjAssignable();
      return $$1;
      }
    case '{':
      {
      const $$1 = this.parseObject();
      return $$1;
      }
    case '(':
      {
      const $$1 = this.parseParenthetical();
      return $$1;
      }
    case 'SUPER':
      {
      const $$1 = this._match('SUPER');
      const $$2 = this.parseArguments();
      return ["super", ...$$2];
      }
    case 'THIS':
      {
      const $$1 = this.parseThis();
      return $$1;
      }
    case 'DYNAMIC_IMPORT':
      {
      const $$1 = this._match('DYNAMIC_IMPORT');
      const $$2 = this.parseArguments();
      return ["import", ...$$2];
      }      default:      this._error(['IDENTIFIER', 'PROPERTY', '@', '{', '(', 'SUPER', 'THIS', 'DYNAMIC_IMPORT'], "Invalid ObjSpreadExpr");    }
  }// NOTE: Simplified - omitted 11 accessor patterns

  parseReturn() {
    this._match('RETURN');

    // Check for indented object
    if (this.la.kind === 'INDENT') {
      this._match('INDENT');
      const obj = this.parseObject();
      this._match('OUTDENT');
      return ["return", obj];
    }

    // Check if there's an expression (must check if we can start an Expression)
    // Don't consume TERMINATOR, OUTDENT, POST_IF, POST_UNLESS, or end markers
    if (this.la.kind !== 'TERMINATOR' && this.la.kind !== 'OUTDENT' &&
        this.la.kind !== 'POST_IF' && this.la.kind !== 'POST_UNLESS' &&
        this.la.kind !== '$end' && this.la.kind !== null) {
      const expr = this.parseExpression();
      return ["return", expr];
    }

    // No expression - just return
    return ["return"];
  }

  parseCode() {
    if (this.la.kind === 'PARAM_START') {
      // With parameters
      this._match('PARAM_START');
      const params = this.parseParamList();
      this._match('PARAM_END');
      const arrow = this.parseFuncGlyph();

      // Check if Block (INDENT) or inline Operation
      if (this.la.kind === 'INDENT') {
        const block = this.parseBlock();
        return [arrow, params, block];
      } else {
        // Inline operation (no INDENT in bracket contexts)
        const operation = this.parseOperation();
        return [arrow, params, operation];
      }
    } else {
      // No parameters: -> body or => body
      const arrow = this.parseFuncGlyph();
      const block = this.parseBlock();
      return [arrow, [], block];
    }
  }

parseCodeLine() {
    switch (this.la.kind) {    case 'PARAM_START':
      {
      const $$1 = this._match('PARAM_START');
      const $$2 = this.parseParamList();
      const $$3 = this._match('PARAM_END');
      const $$4 = this.parseFuncGlyph();
      const $$5 = this.parseLine();
      return [$$4, $$2, $$5];
      }
    case '->':
      {
      const $$1 = this.parseFuncGlyph();
      const $$2 = this.parseLine();
      return [$$1, [], $$2];
      }
    case '=>':
      {
      const $$1 = this.parseFuncGlyph();
      const $$2 = this.parseLine();
      return [$$1, [], $$2];
      }      default:      this._error(['PARAM_START', '->', '=>'], "Invalid CodeLine");    }
  }

parseFuncGlyph() {
    switch (this.la.kind) {    case '->':
      {
      const $$1 = this._match('->');
      return $$1;
      }
    case '=>':
      {
      const $$1 = this._match('=>');
      return $$1;
      }      default:      this._error(['->', '=>'], "Invalid FuncGlyph");    }
  }

parseOptComma() {
    switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      return $$1;
      }      default:      // ε production
      return null;    }
  }

parseParamList() {
    switch (this.la.kind) {    case 'IDENTIFIER':
      {
      const $$1 = this.parseParam();
      const $$2 = this.parseParamListTail();
      return [$$1, ...$$2];
      }
    case '@':
      {
      const $$1 = this.parseParam();
      const $$2 = this.parseParamListTail();
      return [$$1, ...$$2];
      }
    case '[':
      {
      const $$1 = this.parseParam();
      const $$2 = this.parseParamListTail();
      return [$$1, ...$$2];
      }
    case '{':
      {
      const $$1 = this.parseParam();
      const $$2 = this.parseParamListTail();
      return [$$1, ...$$2];
      }
    case '...':
      {
      const $$1 = this.parseParam();
      const $$2 = this.parseParamListTail();
      return [$$1, ...$$2];
      }
    case 'INDENT':
      {
      const $$1 = this._match('INDENT');
      const $$2 = this.parseParamList();
      const $$3 = this.parseOptComma();
      const $$4 = this._match('OUTDENT');
      return $$2;
      }      default:      // ε production
      return [];    }
  }

parseParamListTail() {
    switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      const $$2 = this.parseParam();
      const $$3 = this.parseParamListTail();
      return [$$2, ...$$3];
      }
    case 'TERMINATOR':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('TERMINATOR');
      const $$3 = this.parseParam();
      const $$4 = this.parseParamListTail();
      return [$$3, ...$$4];
      }
    case 'INDENT':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('INDENT');
      const $$3 = this.parseParamList();
      const $$4 = this.parseOptComma();
      const $$5 = this._match('OUTDENT');
      return [...$$3];
      }      default:      // ε production
      return [];    }
  }

  parseParam() {
    // Check for ... (rest or expansion)
    if (this.la.kind === '...') {
      this._match('...');

      // Check if there's a ParamVar after (rest param) or just expansion
      if (this.la.kind === 'IDENTIFIER' || this.la.kind === '@' || this.la.kind === '[' || this.la.kind === '{') {
        const paramVar = this.parseParamVar();
        return ["rest", paramVar];
      } else {
        return ["expansion"];
      }
    }

    // Otherwise parse ParamVar
    const paramVar = this.parseParamVar();

    // Check for default value
    if (this.la.kind === '=') {
      this._match('=');
      const defaultExpr = this.parseExpression();
      return ["default", paramVar, defaultExpr];
    }

    return paramVar;
  }

parseParamVar() {
    switch (this.la.kind) {    case 'IDENTIFIER': return this.parseIdentifier();
    case '@': return this.parseThisProperty();
    case '[': return this.parseArray();
    case '{': return this.parseObject();default:
  this._error(['IDENTIFIER', '@', '[', '{'], "Invalid ParamVar");
    }
  }

parseSplat() {const $$1 = this._match('...');
      const $$2 = this.parseExpression();
      return ["...", $$2];  }

  parseSimpleAssignable() {
    // Accessor chain with full iterative loop
    let base;

    // Parse base case
    switch (this.la.kind) {    case 'IDENTIFIER':
      {
      const $$1 = this._match('IDENTIFIER');
      base = $$1;;
      break;
      }
    case '@':
      {
      const $$1 = this.parseThisProperty();
      base = $$1;;
      break;
      }default:
  this._error([], "Invalid SimpleAssignable");
    }

    // Iterate through accessors
    while (true) {
      switch (this.la.kind) {      case '.':
        this._match('.');
        const prop = this.parseProperty();
        base = ['.', base, prop];
        break;
      case '?.':
        this._match('?.');
        const optProp = this.parseProperty();
        base = ['?.', base, optProp];
        break;
      case '::':
        this._match('::');
        if (this.la.kind === 'PROPERTY') {
          const protoProp = this.parseProperty();
          base = ['::', base, protoProp];
        } else {
          base = ['::', base, 'prototype'];
        }
        break;
      case '?::':
        this._match('?::');
        if (this.la.kind === 'PROPERTY') {
          const optProtoProp = this.parseProperty();
          base = ['?::', base, optProtoProp];
        } else {
          base = ['?::', base, 'prototype'];
        }
        break;
      case 'INDEX_START':
        this._match('INDEX_START');
        
        // Check for regex indexing: value[/pattern/] or value[/pattern/, n]
        if (this.la.kind === 'REGEX' || this.la.kind === 'REGEX_START') {
          const regex = this.parseRegex();
          
          // Check for capture group number: [/pattern/, 1]
          if (this.la.kind === ',') {
            this._match(',');
            const captureNum = this.parseExpression();
            this._match('INDEX_END');
            // Result: ["regex-index", base, regex, captureNum]
            base = ["regex-index", base, regex, captureNum];
          } else {
            // No capture number: [/pattern/]
            this._match('INDEX_END');
            // Result: ["regex-index", base, regex, null]
            base = ["regex-index", base, regex, null];
          }
        } else if (this.la.kind === '..' || this.la.kind === '...') {
          // Slice without start: [..3] or [...3]
          const slice = this.parseSlice();
          this._match('INDEX_END');
          base = ['[]', base, slice];
        } else {
          const index = this.parseExpression();
          // Check if it's a slice: [1..3] or [1...3]
          if (this.la.kind === '..' || this.la.kind === '...') {
            // It's a slice! Parse as Slice
            const dots = this.parseRangeDots();
            let endExpr = null;
            if (this.la.kind !== 'INDEX_END') {
              endExpr = this.parseExpression();
            }
            this._match('INDEX_END');
            base = ['[]', base, [dots, index, endExpr]];
          } else {
            // Simple index
            this._match('INDEX_END');
            base = ['[]', base, index];
          }
        }
        break;
      case 'INDEX_SOAK':
        this._match('INDEX_SOAK');
        this._match('INDEX_START');
        const soakIndex = this.parseExpression();
        this._match('INDEX_END');
        base = ['?[]', base, soakIndex];
        break;        default:
          return base;
      }
    }
  }

  parseAssignable() {
    switch (this.la.kind) {
      case 'IDENTIFIER':
      case '@':
        return this.parseSimpleAssignable();
      case '[':
        return this.parseArray();
      case '{':
        return this.parseObject();
      default:
        this._error(['IDENTIFIER', '@', '[', '{'], "Invalid Assignable");
    }
  }

  parseValue() {
    // Parse base value
    let base;
    switch (this.la.kind) {
      case 'IDENTIFIER':
      case '{':
        base = this.parseAssignable();
        break;
      case 'SUPER':
        // SUPER can be: super.prop, super[expr], or super(args)
        // Consume token and check what follows to determine type
        this._match('SUPER');
        base = "super";  // Base case
        break;
      case 'DYNAMIC_IMPORT':
        // DYNAMIC_IMPORT Arguments → parse as invocation, then handle accessors
        base = this.parseInvocation();
        break;
      case 'DO_IIFE':
        base = this.parseDoIife();
        break;
      case '@':
        // Bare @ alone means "this", but @ followed by more is @property
        this._match('@');
        if (this.la.kind === 'PROPERTY') {
          // @property - parse as this.property
          const prop = this.parseProperty();
          base = ['.', 'this', prop];
        } else {
          // Bare @ means "this"
          base = "this";
        }
        break;
      case 'THIS':
        // THIS keyword maps to "this"
        this._match('THIS');
        base = "this";
        break;
      case 'NEW_TARGET':
      case 'IMPORT_META':
        base = this.parseMetaProperty();
        break;
      case '[':
        // Could be Array or Range - try Range first (it's more specific)
        // Range: [ Expression .. Expression ]
        // Array: [ ... ]
        // We need to lookahead to distinguish, but for now just try Array
        // (Range will be handled if Array sees .. or ...)
        base = this.parseAssignable();
        break;
      case '(':
        // Could be Parenthetical or Assignable with paren
        base = this.parseParenthetical();
        break;
      case 'NUMBER':
      case 'STRING':
      case 'STRING_START':
      case 'JS':
      case 'UNDEFINED':
      case 'NULL':
      case 'BOOL':
      case 'INFINITY':
      case 'NAN':
      case 'REGEX':
      case 'REGEX_START':
        base = this.parseLiteral();
        break;
      default:
        this._error([], "Invalid Value");
    }

    // Handle function calls and accessors iteratively
    while (true) {
      if (this.la.kind === 'CALL_START' || this.la.kind === 'FUNC_EXIST' || this.la.kind === 'ES6_OPTIONAL_CALL') {
        // Function call
        let funcExist = null;
        if (this.la.kind === 'FUNC_EXIST') {
          this._match('FUNC_EXIST');
          funcExist = true;
        } else if (this.la.kind === 'ES6_OPTIONAL_CALL') {
          this._match('ES6_OPTIONAL_CALL');
          // After ES6_OPTIONAL_CALL (?.), there's still a CALL_START to match
          this._match('CALL_START');
          let args = [];
          if (this.la.kind !== 'CALL_END') {
            args = this.parseArgList();
            if (this.la.kind === ',') {
              this._match(',');  // Optional trailing comma
            }
          }
          this._match('CALL_END');
          base = ["optcall", base, ...args];
          continue;
        }

        // Parse Arguments manually (CALL_START ... CALL_END)
        this._match('CALL_START');
        let args = [];
        if (this.la.kind !== 'CALL_END') {
          args = this.parseArgList();
          if (this.la.kind === ',') {
            this._match(',');  // Optional trailing comma
          }
        }
        this._match('CALL_END');

        base = funcExist ? ["?call", base, ...args] : [base, ...args];
      } else if (this.la.kind === '.') {
        // Property access: value.property
        this._match('.');
        const prop = this.parseProperty();
        base = ['.', base, prop];
      } else if (this.la.kind === '?.') {
        // Optional property access: value?.property
        this._match('?.');
        const optProp = this.parseProperty();
        base = ['?.', base, optProp];
      } else if (this.la.kind === '::') {
        // Prototype access: value::property or value::
        this._match('::');
        if (this.la.kind === 'PROPERTY') {
          const protoProp = this.parseProperty();
          base = ['::', base, protoProp];
        } else {
          base = ['::', base, 'prototype'];
        }
      } else if (this.la.kind === '?::') {
        // Optional prototype access: value?::property or value?::
        this._match('?::');
        if (this.la.kind === 'PROPERTY') {
          const optProtoProp = this.parseProperty();
          base = ['?::', base, optProtoProp];
        } else {
          base = ['?::', base, 'prototype'];
        }
      } else if (this.la.kind === 'INDEX_START') {
        // Array indexing, slicing, or regex indexing: value[index] or value[start..end] or value[/regex/, capture]
        this._match('INDEX_START');

        // Check for regex indexing: value[/pattern/] or value[/pattern/, n]
        if (this.la.kind === 'REGEX' || this.la.kind === 'REGEX_START') {
          const regex = this.parseRegex();

          // Check for capture group number: [/pattern/, 1]
          if (this.la.kind === ',') {
            this._match(',');
            const captureNum = this.parseExpression();
            this._match('INDEX_END');
            // SimpleAssignable rule action: [$3[0], $1, ...$3.slice(1)]
            // Where $3 is ["regex-index", regex, captureNum]
            // Result: ["regex-index", base, regex, captureNum]
            base = ["regex-index", base, regex, captureNum];
          } else {
            // No capture number: [/pattern/]
            this._match('INDEX_END');
            // Result: ["regex-index", base, regex, null]
            base = ["regex-index", base, regex, null];
          }
        } else if (this.la.kind === '..' || this.la.kind === '...') {
          // Slice without start: [..3] or [...3]
          const slice = this.parseSlice();
          this._match('INDEX_END');
          base = ['[]', base, slice];
        } else {
          const index = this.parseExpression();
          // Check if it's a slice: [1..3] or [1...3]
          if (this.la.kind === '..' || this.la.kind === '...') {
            // It's a slice! Parse as Slice
            const dots = this.parseRangeDots();
            let endExpr = null;
            if (this.la.kind !== 'INDEX_END') {
              endExpr = this.parseExpression();
            }
            this._match('INDEX_END');
            base = ['[]', base, [dots, index, endExpr]];
          } else {
            // Simple index
            this._match('INDEX_END');
            base = ['[]', base, index];
          }
        }
      } else if (this.la.kind === 'INDEX_SOAK') {
        // Optional indexing: value?[index]
        this._match('INDEX_SOAK');
        this._match('INDEX_START');
        const soakIndex = this.parseExpression();
        this._match('INDEX_END');
        base = ['?[]', base, soakIndex];
      } else if (this.la.kind === 'ES6_OPTIONAL_INDEX') {
        // ES6 optional indexing: value?.[index]
        this._match('ES6_OPTIONAL_INDEX');
        this._match('INDEX_START');
        const optIndex = this.parseExpression();
        this._match('INDEX_END');
        base = ['optindex', base, optIndex];
      } else if (this.la.kind === 'STRING' || this.la.kind === 'STRING_START') {
        // Tagged template: tag`template` or tag"string"
        const str = this.parseString();
        base = ["tagged-template", base, str];
      } else {
        // No more accessors or calls
        break;
      }
    }

    return base;
  }

parseSuper() {
    switch (this.la.kind) {    case 'SUPER':
      {
      const $$1 = this._match('SUPER');
      const $$2 = this._match('.');
      const $$3 = this._match('PROPERTY');
      return [".", "super", $$3];
      }      default:      this._error(['SUPER'], "Invalid Super");    }
  }

parseMetaProperty() {
    switch (this.la.kind) {    case 'NEW_TARGET':
      {
      const $$1 = this._match('NEW_TARGET');
      const $$2 = this._match('.');
      const $$3 = this._match('PROPERTY');
      return [".", "new", $$3];
      }
    case 'IMPORT_META':
      {
      const $$1 = this._match('IMPORT_META');
      const $$2 = this._match('.');
      const $$3 = this._match('PROPERTY');
      return [".", "import", $$3];
      }      default:      this._error(['NEW_TARGET', 'IMPORT_META'], "Invalid MetaProperty");    }
  }

  parseObject() {
    this._match('{');

    // Check for empty object
    if (this.la.kind === '}') {
      this._match('}');
      return ["object"];
    }

    // Parse object properties
    const list = this.parseAssignList();

    // Optional trailing comma
    if (this.la.kind === ',') {
      this._match(',');
    }

    this._match('}');
    return ["object", ...list];
  }

  parseAssignList() {
    // Check for empty object
    if (this.la.kind === '}' || this.la.kind === 'OUTDENT') {
      return [];  // Empty object
    }

    // Check for INDENT case (multiline)
    if (this.la.kind === 'INDENT') {
      this._match('INDENT');
      const list = this.parseAssignList();  // Recursive for multiline
      if (this.la.kind === ',') {
        this._match(',');  // Optional trailing comma
      }
      this._match('OUTDENT');
      return list;
    }

    // Parse first property
    const list = [];
    list.push(this.parseAssignObj());

    // Parse remaining properties
    while (this.la.kind === ',' || this.la.kind === 'TERMINATOR') {
      if (this.la.kind === 'TERMINATOR') {
        // Multiline within list (newline-separated properties)
        this._match('TERMINATOR');
        if (this.la.kind === '}' || this.la.kind === 'OUTDENT') {
          break;  // End of list
        }
        list.push(this.parseAssignObj());
      } else {
        // Comma-separated properties
        this._match(',');
        // Check for trailing comma
        if (this.la.kind === '}' || this.la.kind === 'OUTDENT') {
          break;  // Trailing comma before end
        }
        list.push(this.parseAssignObj());
      }
    }

    return list;
  }

parseAssignListTail() {
    switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      const $$2 = this.parseAssignObj();
      const $$3 = this.parseAssignListTail();
      return [$$2, ...$$3];
      }
    case 'TERMINATOR':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('TERMINATOR');
      const $$3 = this.parseAssignObj();
      const $$4 = this.parseAssignListTail();
      return [$$3, ...$$4];
      }
    case 'INDENT':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('INDENT');
      const $$3 = this.parseAssignList();
      const $$4 = this.parseOptComma();
      const $$5 = this._match('OUTDENT');
      return [...$$3];
      }      default:      // ε production
      return [];    }
  }

  parseClass() {
    this._match('CLASS');

    // Check for optional name (SimpleAssignable)
    let name = null;
    if (this.la.kind === 'IDENTIFIER' || this.la.kind === '@') {
      name = this.parseSimpleAssignable();
    }

    // Check for optional EXTENDS
    let superclass = null;
    if (this.la.kind === 'EXTENDS') {
      this._match('EXTENDS');
      superclass = this.parseExpression();
    }

    // Check for optional Block
    let body = null;
    if (this.la.kind === 'INDENT') {
      body = this.parseBlock();
    }

    // Build result based on what we have
    if (body) {
      return ["class", name, superclass, body];
    } else if (superclass) {
      return ["class", name, superclass];
    } else if (name) {
      return ["class", name, null];
    } else {
      return ["class", null, null];
    }
  }

  parseImport() {
    this._match('IMPORT');

    // Lookahead to determine import type
    if (this.la.kind === 'STRING' || this.la.kind === 'STRING_START') {
      // IMPORT String → side-effect import
      const str = this.parseString();
      return ["import", "{}", str];
    }

    if (this.la.kind === '{') {
      // IMPORT { ... } FROM String
      this._match('{');
      if (this.la.kind === '}') {
        // Empty: IMPORT { } FROM String
        this._match('}');
        this._match('FROM');
        const str = this.parseString();
        return ["import", "{}", str];
      } else {
        // With specifiers: IMPORT { ImportSpecifierList OptComma } FROM String
        const specifiers = this.parseImportSpecifierList();
        if (this.la.kind === ',') {
          this._match(',');  // OptComma
        }
        this._match('}');
        this._match('FROM');
        const str = this.parseString();
        return ["import", specifiers, str];
      }
    }

    // Must be ImportDefaultSpecifier or ImportNamespaceSpecifier
    if (this.la.kind === 'IMPORT_ALL') {
      // IMPORT ImportNamespaceSpecifier FROM String
      const ns = this.parseImportNamespaceSpecifier();
      this._match('FROM');
      const str = this.parseString();
      return ["import", ns, str];
    }

    // ImportDefaultSpecifier (Identifier)
    const defaultSpec = this.parseImportDefaultSpecifier();

    // Check what comes next
    if (this.la.kind === 'FROM') {
      // Simple: IMPORT ImportDefaultSpecifier FROM String
      this._match('FROM');
      const str = this.parseString();
      return ["import", defaultSpec, str];
    }

    if (this.la.kind === ',') {
      this._match(',');

      if (this.la.kind === 'IMPORT_ALL') {
        // IMPORT ImportDefaultSpecifier , ImportNamespaceSpecifier FROM String
        const ns = this.parseImportNamespaceSpecifier();
        this._match('FROM');
        const str = this.parseString();
        return ["import", [defaultSpec, ns], str];
      }

      if (this.la.kind === '{') {
        // IMPORT ImportDefaultSpecifier , { ImportSpecifierList OptComma } FROM String
        this._match('{');
        const specifiers = this.parseImportSpecifierList();
        if (this.la.kind === ',') {
          this._match(',');
        }
        this._match('}');
        this._match('FROM');
        const str = this.parseString();
        return ["import", [defaultSpec, specifiers], str];
      }
    }

    this._error(['STRING', 'STRING_START', '{', 'IMPORT_ALL', 'FROM'], "Invalid Import");
  }

parseImportSpecifierList() {
    switch (this.la.kind) {    case 'IDENTIFIER':
      {
      const $$1 = this.parseImportSpecifier();
      const $$2 = this.parseImportSpecifierListTail();
      return [$$1, ...$$2];
      }
    case 'DEFAULT':
      {
      const $$1 = this.parseImportSpecifier();
      const $$2 = this.parseImportSpecifierListTail();
      return [$$1, ...$$2];
      }
    case 'INDENT':
      {
      const $$1 = this._match('INDENT');
      const $$2 = this.parseImportSpecifierList();
      const $$3 = this.parseOptComma();
      const $$4 = this._match('OUTDENT');
      return $$2;
      }      default:      this._error(['IDENTIFIER', 'DEFAULT', 'INDENT'], "Invalid ImportSpecifierList");    }
  }

parseImportSpecifierListTail() {
    switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      const $$2 = this.parseImportSpecifier();
      const $$3 = this.parseImportSpecifierListTail();
      return [$$2, ...$$3];
      }
    case 'TERMINATOR':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('TERMINATOR');
      const $$3 = this.parseImportSpecifier();
      const $$4 = this.parseImportSpecifierListTail();
      return [$$3, ...$$4];
      }
    case 'INDENT':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('INDENT');
      const $$3 = this.parseImportSpecifierList();
      const $$4 = this.parseOptComma();
      const $$5 = this._match('OUTDENT');
      return [...$$3];
      }      default:      // ε production
      return [];    }
  }

  parseImportSpecifier() {
    if (this.la.kind === 'IDENTIFIER') {
      const id = this.parseIdentifier();

      // Check for AS (alias)
      if (this.la.kind === 'AS') {
        this._match('AS');
        const alias = this.parseIdentifier();
        return [id, alias];
      }

      // No alias - just return identifier
      return id;
    } else if (this.la.kind === 'DEFAULT') {
      const def = this._match('DEFAULT');

      // Check for AS (alias)
      if (this.la.kind === 'AS') {
        this._match('AS');
        const alias = this.parseIdentifier();
        return [def, alias];
      }

      // No alias - just return DEFAULT
      return def;
    }

    this._error(['IDENTIFIER', 'DEFAULT'], "Invalid ImportSpecifier");
  }

parseImportDefaultSpecifier() {const $$1 = this._match('IDENTIFIER');
      return $$1;  }

parseImportNamespaceSpecifier() {const $$1 = this._match('IMPORT_ALL');
      const $$2 = this._match('AS');
      const $$3 = this._match('IDENTIFIER');
      return ["*", $$3];  }

  parseExport() {
    this._match('EXPORT');

    // Check what comes after EXPORT
    if (this.la.kind === '{') {
      // Could be: { } or { ExportSpecifierList } or { } FROM or { ExportSpecifierList } FROM
      this._match('{');

      if (this.la.kind === '}') {
        // Empty braces: EXPORT { } or EXPORT { } FROM String
        this._match('}');

        if (this.la.kind === 'FROM') {
          // EXPORT { } FROM String
          this._match('FROM');
          const str = this.parseString();
          return ["export-from", "{}", str];
        } else {
          // EXPORT { }
          return ["export", "{}"];
        }
      } else {
        // With specifiers: EXPORT { ExportSpecifierList OptComma }
        const specifiers = this.parseExportSpecifierList();
        if (this.la.kind === ',') {
          this._match(',');  // OptComma
        }
        this._match('}');

        if (this.la.kind === 'FROM') {
          // EXPORT { ExportSpecifierList } FROM String
          this._match('FROM');
          const str = this.parseString();
          return ["export-from", specifiers, str];
        } else {
          // EXPORT { ExportSpecifierList }
          return ["export", specifiers];
        }
      }
    } else if (this.la.kind === 'CLASS') {
      // EXPORT Class
      const cls = this.parseClass();
      return ["export", cls];
    } else if (this.la.kind === 'DEF') {
      // EXPORT Def
      const def = this.parseDef();
      return ["export", def];
    } else if (this.la.kind === 'DEFAULT') {
      // EXPORT DEFAULT Expression or EXPORT DEFAULT INDENT Object OUTDENT
      this._match('DEFAULT');

      if (this.la.kind === 'INDENT') {
        // EXPORT DEFAULT INDENT Object OUTDENT
        this._match('INDENT');
        const obj = this.parseObject();
        this._match('OUTDENT');
        return ["export-default", obj];
      } else {
        // EXPORT DEFAULT Expression
        const expr = this.parseExpression();
        return ["export-default", expr];
      }
    } else if (this.la.kind === 'EXPORT_ALL') {
      // EXPORT EXPORT_ALL FROM String
      this._match('EXPORT_ALL');
      this._match('FROM');
      const str = this.parseString();
      return ["export-all", str];
    } else if (this.la.kind === 'IDENTIFIER') {
      // EXPORT Identifier = Expression (with optional TERMINATOR or INDENT)
      const id = this.parseIdentifier();
      this._match('=');

      if (this.la.kind === 'INDENT') {
        // EXPORT Identifier = INDENT Expression OUTDENT
        this._match('INDENT');
        const expr = this.parseExpression();
        this._match('OUTDENT');
        return ["export", ["=", id, expr]];
      } else if (this.la.kind === 'TERMINATOR') {
        // EXPORT Identifier = TERMINATOR Expression
        this._match('TERMINATOR');
        const expr = this.parseExpression();
        return ["export", ["=", id, expr]];
      } else {
        // EXPORT Identifier = Expression
        const expr = this.parseExpression();
        return ["export", ["=", id, expr]];
      }
    }

    this._error(['{', 'CLASS', 'DEF', 'DEFAULT', 'EXPORT_ALL', 'IDENTIFIER'], "Invalid Export");
  }

parseExportSpecifierList() {
    switch (this.la.kind) {    case 'IDENTIFIER':
      {
      const $$1 = this.parseExportSpecifier();
      const $$2 = this.parseExportSpecifierListTail();
      return [$$1, ...$$2];
      }
    case 'DEFAULT':
      {
      const $$1 = this.parseExportSpecifier();
      const $$2 = this.parseExportSpecifierListTail();
      return [$$1, ...$$2];
      }
    case 'INDENT':
      {
      const $$1 = this._match('INDENT');
      const $$2 = this.parseExportSpecifierList();
      const $$3 = this.parseOptComma();
      const $$4 = this._match('OUTDENT');
      return $$2;
      }      default:      this._error(['IDENTIFIER', 'DEFAULT', 'INDENT'], "Invalid ExportSpecifierList");    }
  }

parseExportSpecifierListTail() {
    switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      const $$2 = this.parseExportSpecifier();
      const $$3 = this.parseExportSpecifierListTail();
      return [$$2, ...$$3];
      }
    case 'TERMINATOR':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('TERMINATOR');
      const $$3 = this.parseExportSpecifier();
      const $$4 = this.parseExportSpecifierListTail();
      return [$$3, ...$$4];
      }
    case 'INDENT':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('INDENT');
      const $$3 = this.parseExportSpecifierList();
      const $$4 = this.parseOptComma();
      const $$5 = this._match('OUTDENT');
      return [...$$3];
      }      default:      // ε production
      return [];    }
  }

  parseExportSpecifier() {
    if (this.la.kind === 'IDENTIFIER') {
      const id = this.parseIdentifier();

      // Check for AS (alias)
      if (this.la.kind === 'AS') {
        this._match('AS');

        if (this.la.kind === 'DEFAULT') {
          // Identifier AS DEFAULT (export as default)
          const def = this._match('DEFAULT');
          return [id, def];
        } else {
          // Identifier AS Identifier (regular alias)
          const alias = this.parseIdentifier();
          return [id, alias];
        }
      }

      // No alias - just return identifier
      return id;
    } else if (this.la.kind === 'DEFAULT') {
      const def = this._match('DEFAULT');

      // Check for AS (alias)
      if (this.la.kind === 'AS') {
        this._match('AS');
        const alias = this.parseIdentifier();
        return [def, alias];
      }

      // No alias - just return DEFAULT
      return def;
    }

    this._error(['IDENTIFIER', 'DEFAULT'], "Invalid ExportSpecifier");
  }

  parseInvocation() {
    // Check for special starting tokens
    if (this.la.kind === 'SUPER') {
      // SUPER OptFuncExist Arguments
      this._match('SUPER');
      const funcExist = this.parseOptFuncExist();
      const args = this.parseArguments();
      return funcExist ? ["?super", ...args] : ["super", ...args];
    } else if (this.la.kind === 'DYNAMIC_IMPORT') {
      // DYNAMIC_IMPORT Arguments
      this._match('DYNAMIC_IMPORT');
      const args = this.parseArguments();
      return ["import", ...args];
    } else {
      // Assignable OptFuncExist (String | Arguments | ES6_OPTIONAL_CALL Arguments)
      const assignable = this.parseAssignable();

      // Check for ES6_OPTIONAL_CALL
      if (this.la.kind === 'ES6_OPTIONAL_CALL') {
        this._match('ES6_OPTIONAL_CALL');
        const args = this.parseArguments();
        return ["optcall", assignable, ...args];
      }

      const funcExist = this.parseOptFuncExist();

      // Lookahead: String (tagged template) or Arguments (call)
      if (this.la.kind === 'STRING' || this.la.kind === 'STRING_START') {
        const str = this.parseString();
        return ["tagged-template", assignable, str];
      } else {
        // Must be Arguments (CALL_START)
        const args = this.parseArguments();
        return funcExist ? ["?call", assignable, ...args] : [assignable, ...args];
      }
    }
  }

parseOptFuncExist() {
    switch (this.la.kind) {    case 'FUNC_EXIST':
      {
      const $$1 = this._match('FUNC_EXIST');
      return true;
      }      default:      // ε production
      return null;    }
  }

  parseArguments() {
    this._match('CALL_START');

    // Check if arguments are empty
    if (this.la.kind === 'CALL_END') {
      this._match('CALL_END');
      return [];
    }

    // Parse argument list
    const args = this.parseArgList();

    // Optional trailing comma
    if (this.la.kind === ',') {
      this._match(',');
    }

    this._match('CALL_END');
    return args;
  }

parseThis() {
    switch (this.la.kind) {    case 'THIS':
      {
      const $$1 = this._match('THIS');
      return "this";
      }
    case '@':
      {
      const $$1 = this._match('@');
      return "this";
      }      default:      this._error(['THIS', '@'], "Invalid This");    }
  }

parseThisProperty() {const $$1 = this._match('@');
      const $$2 = this._match('PROPERTY');
      return [".", "this", $$2];  }

  parseArray() {
    this._match('[');

    // Check for empty array
    if (this.la.kind === ']') {
      this._match(']');
      return ["array"];
    }

    // Check for multiline array with INDENT
    if (this.la.kind === 'INDENT') {
      this._match('INDENT');
      // Parse array contents (after INDENT, before OUTDENT)
      // Use parseArgList which handles multiline properly
      let list = [];
      if (this.la.kind !== 'OUTDENT') {
        list = this.parseArgList();
        if (this.la.kind === ',') {
          this._match(',');  // Optional trailing comma
        }
      }
      this._match('OUTDENT');
      this._match(']');
      return ["array", ...list];
    }

    // Build array element list, handling commas inline
    let list = [];

    // Handle leading commas (elisions at start)
    while (this.la.kind === ',') {
      list.push(",");  // Hole
      this._match(',');
      if (this.la.kind === ']') {
        // All holes: [,,]
        this._match(']');
        return ["array", ...list];
      }
    }

    // Now handle first element if not already at end
    if (this.la.kind === ']') {
      this._match(']');
      return ["array", ...list];
    }

    // Parse first element/expression
    // Could be:
    // - Start of array: [1, 2, 3]
    // - Start of range: [1..3] or [1...4]
    // - Spread: [...arr, 1]
    let firstExpr;
    if (this.la.kind === '...') {
      firstExpr = this.parseSplat();
    } else {
      firstExpr = this.parseExpression();
    }

    // Check for range operators
    if (this.la.kind === '..' || this.la.kind === '...') {
      // It's a Range! [ Expression RangeDots Expression ]
      const dots = this.parseRangeDots();
      const secondExpr = this.parseExpression();
      this._match(']');
      return [dots, firstExpr, secondExpr];
    }

    // It's an Array - parse remaining elements
    // We already have first element (and maybe leading holes), now check for more
    list.push(firstExpr);

    // Parse rest of array (commas and more elements)
    while (this.la.kind === ',') {
      this._match(',');
      // Check for closing bracket (just trailing separator, no hole)
      if (this.la.kind === ']') {
        break;  // Trailing comma - don't add hole
      }
      // Check for elision (another comma means a hole)
      if (this.la.kind === ',') {
        list.push(",");  // Comma string represents hole in s-expression
        continue;
      }
      // Check for spread operator
      if (this.la.kind === '...') {
        const splat = this.parseSplat();
        list.push(splat);
        continue;
      }
      // Parse next element
      const elem = this.parseExpression();
      list.push(elem);
    }

    this._match(']');
    return ["array", ...list];
  }

parseRangeDots() {
    switch (this.la.kind) {    case '..':
      {
      const $$1 = this._match('..');
      return "..";
      }
    case '...':
      {
      const $$1 = this._match('...');
      return "...";
      }      default:      this._error(['..', '...'], "Invalid RangeDots");    }
  }

parseRange() {const $$1 = this._match('[');
      const $$2 = this.parseExpression();
      const $$3 = this.parseRangeDots();
      const $$4 = this.parseExpression();
      const $$5 = this._match(']');
      return [$$3, $$2, $$4];  }

  parseSlice() {
    // Check if it starts with RangeDots
    if (this.la.kind === '..' || this.la.kind === '...') {
      const dots = this.parseRangeDots();

      // Check if there's an expression after
      // Must check if we can start an Expression (not at INDEX_END, OUTDENT, etc.)
      if (this.la.kind !== 'INDEX_END' && this.la.kind !== 'OUTDENT') {
        const endExpr = this.parseExpression();
        return [dots, null, endExpr];  // Rule 3: RangeDots Expression
      } else {
        return [dots, null, null];  // Rule 4: RangeDots only
      }
    }

    // Otherwise parse Expression first
    const startExpr = this.parseExpression();

    // Check for RangeDots after expression
    if (this.la.kind === '..' || this.la.kind === '...') {
      const dots = this.parseRangeDots();

      // Check if there's an expression after
      if (this.la.kind !== 'INDEX_END' && this.la.kind !== 'OUTDENT') {
        const endExpr = this.parseExpression();
        return [dots, startExpr, endExpr];  // Rule 1: Expression RangeDots Expression
      } else {
        return [dots, startExpr, null];  // Rule 2: Expression RangeDots
      }
    }

    // No RangeDots found - this shouldn't happen in valid Slice context
    this._error(['..',  '...'], "Invalid Slice");
  }

  parseArgList() {
    // Check for INDENT case (multiline)
    if (this.la.kind === 'INDENT') {
      this._match('INDENT');
      const list = this.parseArgList();  // Recursive for multiline
      if (this.la.kind === ',') {
        this._match(',');  // Optional trailing comma
      }
      this._match('OUTDENT');
      return list;
    }

    // Parse first argument
    const list = [];
    list.push(this.parseArg());

    // Parse remaining arguments
    while (this.la.kind === ',' || this.la.kind === 'TERMINATOR') {
      if (this.la.kind === 'TERMINATOR') {
        // Multiline within list (newline-separated args)
        this._match('TERMINATOR');
        if (this.la.kind === 'CALL_END' || this.la.kind === ']') {
          break;  // End of list
        }
        list.push(this.parseArg());
      } else {
        // Comma-separated args
        this._match(',');
        // Check for trailing comma
        if (this.la.kind === 'CALL_END' || this.la.kind === ']' || this.la.kind === 'OUTDENT') {
          break;  // Trailing comma before end
        }
        // Check for TERMINATOR after comma (multiline with trailing comma)
        if (this.la.kind === 'TERMINATOR') {
          continue;  // Let next iteration handle TERMINATOR
        }
        list.push(this.parseArg());
      }
    }

    return list;
  }

parseArgListTail() {
    switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      const $$2 = this.parseArg();
      const $$3 = this.parseArgListTail();
      return [$$2, ...$$3];
      }
    case 'TERMINATOR':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('TERMINATOR');
      const $$3 = this.parseArg();
      const $$4 = this.parseArgListTail();
      return [$$3, ...$$4];
      }
    case 'INDENT':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('INDENT');
      const $$3 = this.parseArgList();
      const $$4 = this.parseOptComma();
      const $$5 = this._match('OUTDENT');
      return [...$$3];
      }      default:      // ε production
      return [];    }
  }

parseArg() {
    switch (this.la.kind) {    case 'IF': return this.parseExpression();
    case 'UNLESS': return this.parseExpression();
    case 'FOR': return this.parseExpression();
    case 'WHILE': return this.parseExpression();
    case 'UNTIL': return this.parseExpression();
    case 'LOOP': return this.parseExpression();
    case 'TRY': return this.parseExpression();
    case 'SWITCH': return this.parseExpression();
    case 'DEF': return this.parseExpression();
    case 'CLASS': return this.parseExpression();
    case 'PARAM_START': return this.parseExpression();
    case '->': return this.parseExpression();
    case '=>': return this.parseExpression();
    case 'YIELD': return this.parseExpression();
    case 'THROW': return this.parseExpression();
    case 'IDENTIFIER': return this.parseExpression();
    case '@': return this.parseExpression();
    case '[': return this.parseExpression();
    case '{': return this.parseExpression();
    case 'NUMBER': return this.parseExpression();
    case 'JS': return this.parseExpression();
    case 'REGEX': return this.parseExpression();
    case 'REGEX_START': return this.parseExpression();
    case 'UNDEFINED': return this.parseExpression();
    case 'NULL': return this.parseExpression();
    case 'BOOL': return this.parseExpression();
    case 'INFINITY': return this.parseExpression();
    case 'NAN': return this.parseExpression();
    case '(': return this.parseExpression();
    case 'SUPER': return this.parseExpression();
    case 'DYNAMIC_IMPORT': return this.parseExpression();
    case 'DO_IIFE': return this.parseExpression();
    case 'THIS': return this.parseExpression();
    case 'NEW_TARGET': return this.parseExpression();
    case 'IMPORT_META': return this.parseExpression();
    case 'STRING': return this.parseExpression();
    case 'STRING_START': return this.parseExpression();
    case 'UNARY': return this.parseExpression();
    case 'DO': return this.parseExpression();
    case 'UNARY_MATH': return this.parseExpression();
    case '-': return this.parseExpression();
    case '+': return this.parseExpression();
    case 'AWAIT': return this.parseExpression();
    case '--': return this.parseExpression();
    case '++': return this.parseExpression();
    case '...': return this.parseSplat();default:
  this._error(['IF', 'UNLESS', 'FOR', 'WHILE', 'UNTIL', 'LOOP', 'TRY', 'SWITCH', 'DEF', 'CLASS', 'PARAM_START', '->', '=>', 'YIELD', 'THROW', 'IDENTIFIER', '@', '[', '{', 'NUMBER', 'JS', 'REGEX', 'REGEX_START', 'UNDEFINED', 'NULL', 'BOOL', 'INFINITY', 'NAN', '(', 'SUPER', 'DYNAMIC_IMPORT', 'DO_IIFE', 'THIS', 'NEW_TARGET', 'IMPORT_META', 'STRING', 'STRING_START', 'UNARY', 'DO', 'UNARY_MATH', '-', '+', 'AWAIT', '--', '++', '...'], "Invalid Arg");
    }
  }

  parseArgElisionList() {
    // Check for INDENT case (multiline)
    if (this.la.kind === 'INDENT') {
      this._match('INDENT');
      const list = this.parseArgElisionList();  // Recursive for multiline
      const elisions = this.parseOptElisions();
      this._match('OUTDENT');
      return [...list, ...elisions];
    }

    // Parse first element (may have elisions)
    const list = [];
    const first = this.parseArgElision();
    list.push(...first);

    // Parse remaining elements
    while (this.la.kind === ',' || this.la.kind === 'TERMINATOR') {
      if (this.la.kind === 'TERMINATOR') {
        // Multiline within list
        this._match('TERMINATOR');
        if (this.la.kind === ']' || this.la.kind === 'OUTDENT') {
          break;  // End of list
        }
        const elem = this.parseArgElision();
        list.push(...elem);
      } else {
        // Comma-separated
        this._match(',');
        // Check for trailing comma or end
        if (this.la.kind === ']' || this.la.kind === 'OUTDENT') {
          break;  // Trailing comma before end
        }
        const elem = this.parseArgElision();
        list.push(...elem);
      }
    }

    return list;
  }

parseArgElisionListTail() {
    switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      const $$2 = this.parseArgElision();
      const $$3 = this.parseArgElisionListTail();
      return [...$$2, ...$$3];
      }
    case 'TERMINATOR':
      {
      const $$1 = this.parseOptComma();
      const $$2 = this._match('TERMINATOR');
      const $$3 = this.parseArgElision();
      const $$4 = this.parseArgElisionListTail();
      return [...$$3, ...$$4];
      }
    case 'INDENT':
      {
      const $$1 = this.parseOptElisions();
      const $$2 = this._match('INDENT');
      const $$3 = this.parseArgElisionList();
      const $$4 = this.parseOptElisions();
      const $$5 = this._match('OUTDENT');
      return [...$$1, ...$$3, ...$$4];
      }      default:      // ε production
      return [];    }
  }

parseArgElision() {
    switch (this.la.kind) {    case 'IF':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'UNLESS':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'FOR':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'WHILE':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'UNTIL':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'LOOP':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'TRY':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'SWITCH':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'DEF':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'CLASS':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'PARAM_START':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '->':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '=>':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'YIELD':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'THROW':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'IDENTIFIER':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '@':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'JS':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'UNDEFINED':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'NULL':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'BOOL':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'INFINITY':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'NAN':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '(':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '[':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'SUPER':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'DYNAMIC_IMPORT':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'DO_IIFE':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'THIS':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'NEW_TARGET':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'IMPORT_META':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '{':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'NUMBER':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'STRING':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'STRING_START':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'REGEX':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'REGEX_START':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'UNARY':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'DO':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'UNARY_MATH':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '-':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '+':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case 'AWAIT':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '--':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '++':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case '...':
      {
      const $$1 = this.parseArg();
      return [$$1];
      }
    case ',':
      {
      const $$1 = this.parseElisions();
      const $$2 = this.parseArg();
      return [...$$1, $$2];
      }      default:      this._error(['IF', 'UNLESS', 'FOR', 'WHILE', 'UNTIL', 'LOOP', 'TRY', 'SWITCH', 'DEF', 'CLASS', 'PARAM_START', '->', '=>', 'YIELD', 'THROW', 'IDENTIFIER', '@', 'JS', 'UNDEFINED', 'NULL', 'BOOL', 'INFINITY', 'NAN', '(', '[', 'SUPER', 'DYNAMIC_IMPORT', 'DO_IIFE', 'THIS', 'NEW_TARGET', 'IMPORT_META', '{', 'NUMBER', 'STRING', 'STRING_START', 'REGEX', 'REGEX_START', 'UNARY', 'DO', 'UNARY_MATH', '-', '+', 'AWAIT', '--', '++', '...', ','], "Invalid ArgElision");    }
  }

parseOptElisions() {
    switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      const $$2 = this.parseElisions();
      return [...$$2];
      }      default:      this._error([','], "Invalid OptElisions");    }
  }

  parseElisions() {
    // List pattern: Elisions → Elision ElisionsTail
    const $$1 = this.parseElision();
    const $$2 = this.parseElisionsTail();
    return [$$1, ...$$2];
  }

parseElisionsTail() {
    switch (this.la.kind) {    case ',':
      {
      const $$1 = this.parseElision();
      const $$2 = this.parseElisionsTail();
      return [$$1, ...$$2];
      }      default:      // ε production
      return [];    }
  }

parseElision() {
    switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      return null;
      }      default:      this._error([','], "Invalid Elision");    }
  }

  parseSimpleArgs() {
    // List pattern: SimpleArgs → Expression SimpleArgsTail
    const $$1 = this.parseExpression();
    const $$2 = this.parseSimpleArgsTail();
    return Array.isArray($$2) && $$2.length > 0 ? [$$1, ...$$2] : $$1;
  }

parseSimpleArgsTail() {
    switch (this.la.kind) {    case ',':
      {
      const $$1 = this._match(',');
      const $$2 = this.parseExpression();
      const $$3 = this.parseSimpleArgsTail();
      return [$$2, ...$$3];
      }      default:      // ε production
      return [];    }
  }

  parseTry() {
    this._match('TRY');
    const tryBlock = this.parseBlock();

    // Check for Catch
    let catchClause = null;
    if (this.la.kind === 'CATCH') {
      catchClause = this.parseCatch();
    }

    // Check for Finally
    if (this.la.kind === 'FINALLY') {
      this._match('FINALLY');
      const finallyBlock = this.parseBlock();
      if (catchClause) {
        return ["try", tryBlock, catchClause, finallyBlock];
      } else {
        return ["try", tryBlock, finallyBlock];
      }
    }

    // Just try-catch or try only
    if (catchClause) {
      return ["try", tryBlock, catchClause];
    } else {
      return ["try", tryBlock];
    }
  }

  parseCatch() {
    this._match('CATCH');

    // Lookahead to determine which variant
    if (this.la.kind === 'INDENT') {
      // CATCH Block (no parameter)
      const block = this.parseBlock();
      return [null, block];
    } else if (this.la.kind === '{') {
      // CATCH Object Block (object destructuring)
      const pattern = this.parseObject();
      const block = this.parseBlock();
      return [pattern, block];
    } else {
      // CATCH Identifier Block (simple parameter)
      const param = this.parseIdentifier();
      const block = this.parseBlock();
      return [param, block];
    }
  }

parseThrow() {
    switch (this.la.kind) {    case 'THROW':
      {
      const $$1 = this._match('THROW');
      const $$2 = this.parseExpression();
      return ["throw", $$2];
      }      default:      this._error(['THROW'], "Invalid Throw");    }
  }

parseParenthetical() {
    switch (this.la.kind) {    case '(':
      {
      const $$1 = this._match('(');
      const $$2 = this.parseBody();
      const $$3 = this._match(')');
      return $$2.length === 1 ? $$2[0] : $$2;
      }      default:      this._error(['('], "Invalid Parenthetical");    }
  }

parseWhileSource() {
    switch (this.la.kind) {    case 'WHILE':
      {
      const $$1 = this._match('WHILE');
      const $$2 = this.parsePrimaryExpression();
      return ["while", $$2];
      }
    case 'UNTIL':
      {
      const $$1 = this._match('UNTIL');
      const $$2 = this.parsePrimaryExpression();
      return ["until", $$2];
      }      default:      this._error(['WHILE', 'UNTIL'], "Invalid WhileSource");    }
  }

parseWhile() {
    switch (this.la.kind) {    case 'WHILE':
      {
      const $$1 = this.parseWhileSource();
      const $$2 = this.parseBlock();
      return $$1.length === 2 ? [$$1[0], $$1[1], $$2]   : [$$1[0], $$1[1], $$1[2], $$2];
      }
    case 'UNTIL':
      {
      const $$1 = this.parseWhileSource();
      const $$2 = this.parseBlock();
      return $$1.length === 2 ? [$$1[0], $$1[1], $$2]   : [$$1[0], $$1[1], $$1[2], $$2];
      }
    case 'LOOP':
      {
      const $$1 = this.parseLoop();
      return $$1;
      }      default:      this._error(['WHILE', 'UNTIL', 'LOOP'], "Invalid While");    }
  }

parseLoop() {
    switch (this.la.kind) {    case 'LOOP':
      {
      const $$1 = this._match('LOOP');
      const $$2 = this.parseBlock();
      return ["loop", $$2];
      }      default:      this._error(['LOOP'], "Invalid Loop");    }
  }

  parseFor() {
    // Check if it starts with FOR keyword
    if (this.la.kind === 'FOR') {
      this._match('FOR');

      // Check for AWAIT (FOR AWAIT ForVariables FORFROM...)
      let hasAwait = false;
      if (this.la.kind === 'AWAIT') {
        this._match('AWAIT');
        hasAwait = true;
      }

      // Check for OWN (FOR OWN ForVariables FOROF...)
      let hasOwn = false;
      if (this.la.kind === 'OWN') {
        this._match('OWN');
        hasOwn = true;
      }

      // Check what comes next: ForVariables or Range
      // Note: Range loops (FOR [1..10]) only valid without AWAIT/OWN
      if (this.la.kind === '[' && !hasAwait && !hasOwn) {
        // FOR Range Block (simple range-based loop)
        const range = this.parseRange();

        // Optional BY
        let byExpr = null;
        if (this.la.kind === 'BY') {
          this._match('BY');
          byExpr = this.parseExpression();
        }

        const block = this.parseBlock();
        return ["for-in", [], range, byExpr, null, block];
      } else {
        // FOR ForVariables FORIN/FOROF/FORFROM Expression
        const vars = this.parseForVariables();

        // Check loop type
        if (this.la.kind === 'FORIN') {
          this._match('FORIN');
          const expr = this.parseExpression();

          // Optional BY
          let byExpr = null;
          if (this.la.kind === 'BY') {
            this._match('BY');
            byExpr = this.parseExpression();
          }

          // Optional WHEN
          let whenExpr = null;
          if (this.la.kind === 'WHEN') {
            this._match('WHEN');
            whenExpr = this.parseExpression();
          }

          const block = this.parseBlock();
          return ["for-in", vars, expr, byExpr, whenExpr, block];
        } else if (this.la.kind === 'FOROF') {
          this._match('FOROF');
          const expr = this.parseExpression();

          // Optional WHEN
          let whenExpr = null;
          if (this.la.kind === 'WHEN') {
            this._match('WHEN');
            whenExpr = this.parseExpression();
          }

          const block = this.parseBlock();
          return ["for-of", vars, expr, hasOwn, whenExpr, block];
        } else if (this.la.kind === 'FORFROM') {
          this._match('FORFROM');
          const expr = this.parseExpression();

          // Optional WHEN
          let whenExpr = null;
          if (this.la.kind === 'WHEN') {
            this._match('WHEN');
            whenExpr = this.parseExpression();
          }

          const block = this.parseBlock();
          return ["for-from", vars, expr, hasAwait, whenExpr, block];
        } else {
          this._error(['FORIN', 'FOROF', 'FORFROM'], "Expected for loop type");
        }
      }
    } else {
      // Not FOR keyword at all
      this._error(['FOR'], "Invalid For");
    }
  }

  parseForValue() {
    const forVar = this.parseForVar();

    // Check for default value
    if (this.la.kind === '=') {
      this._match('=');
      const defaultExpr = this.parseExpression();
      return ["default", forVar, defaultExpr];
    }

    // No default - just return the variable
    return forVar;
  }

parseForVar() {
    switch (this.la.kind) {    case 'IDENTIFIER': return this.parseIdentifier();
    case '@': return this.parseThisProperty();
    case '[': return this.parseArray();
    case '{': return this.parseObject();default:
  this._error(['IDENTIFIER', '@', '[', '{'], "Invalid ForVar");
    }
  }

  parseForVariables() {
    const first = this.parseForValue();

    // Check for comma (two variables: value, index)
    if (this.la.kind === ',') {
      this._match(',');
      const second = this.parseForValue();
      return [first, second];
    }

    // Just one variable
    return [first];
  }

  parseSwitch() {
    this._match('SWITCH');

    // Lookahead: if INDENT, no discriminant; otherwise parse Expression
    let discriminant = null;
    if (this.la.kind !== 'INDENT') {
      discriminant = this.parseExpression();
    }

    // Now expect INDENT
    this._match('INDENT');

    // Parse when clauses
    const whens = this.parseWhens();

    // Check for ELSE
    let elseBlock = null;
    if (this.la.kind === 'ELSE') {
      this._match('ELSE');
      elseBlock = this.parseBlock();
    }

    this._match('OUTDENT');

    return ["switch", discriminant, whens, elseBlock];
  }

  parseWhens() {
    // List pattern: Whens → When WhensTail
    const $$1 = this.parseWhen();
    const $$2 = this.parseWhensTail();
    return [$$1, ...$$2];
  }

parseWhensTail() {
    switch (this.la.kind) {    case 'LEADING_WHEN':
      {
      const $$1 = this.parseWhen();
      const $$2 = this.parseWhensTail();
      return [$$1, ...$$2];
      }      default:      // ε production
      return [];    }
  }

  parseWhen() {
    this._match('LEADING_WHEN');
    const args = this.parseSimpleArgs();
    const block = this.parseBlock();

    // Optionally consume trailing TERMINATOR (for when clauses in switch)
    if (this.la.kind === 'TERMINATOR') {
      this._match('TERMINATOR');
    }

    return ["when", args, block];
  }

parseIfBlock() {const $$1 = this._match('IF');
      const $$2 = this.parseOperation();
      const $$3 = this.parseBlock();
      return ["if", $$2, $$3];  }

  parseUnlessBlock() {
    this._match('UNLESS');
    const condition = this.parseOperation();
    const thenBlock = this.parseBlock();

    // Check for ELSE
    if (this.la.kind === 'ELSE') {
      this._match('ELSE');
      const elseBlock = this.parseBlock();
      // unless with else = if not
      return ["if", ["!", condition], thenBlock, elseBlock];
    }

    // No else - just unless
    return ["unless", condition, thenBlock];
  }

  parseIf() {
    // Parse IfBlock or UnlessBlock
    let result;
    if (this.la.kind === 'IF') {
      result = this.parseIfBlock();
    } else if (this.la.kind === 'UNLESS') {
      result = this.parseUnlessBlock();
    } else {
      this._error(['IF', 'UNLESS'], "Invalid If");
    }

    // Check for ELSE continuation
    if (this.la.kind === 'ELSE') {
      this._match('ELSE');

      // Lookahead: Is it ELSE If (else-if) or ELSE Block (final else)?
      if (this.la.kind === 'IF' || this.la.kind === 'UNLESS') {
        // ELSE If - right-recursive else-if chain!
        const elseIf = this.parseIf();  // Recursive call
        // Append else-if to result
        if (result.length === 3) {
          return ["if", result[1], result[2], elseIf];
        } else {
          return [...result, elseIf];
        }
      } else {
        // ELSE Block - final else
        const elseBlock = this.parseBlock();
        // Append else block to if
        if (result.length === 3) {
          return ["if", result[1], result[2], elseBlock];
        } else {
          return [...result, elseBlock];
        }
      }
    }

    return result;
  }

parseOperationLine() {
    switch (this.la.kind) {    case 'UNARY':
      {
      const $$1 = this._match('UNARY');
      const $$2 = this.parseExpressionLine();
      return [$$1, $$2];
      }
    case 'DO':
      {
      const $$1 = this._match('DO');
      const $$2 = this.parseExpressionLine();
      return ["do-iife", $$2];
      }
    case 'DO_IIFE':
      {
      const $$1 = this._match('DO_IIFE');
      const $$2 = this.parseCodeLine();
      return ["do-iife", $$2];
      }      default:      this._error(['UNARY', 'DO', 'DO_IIFE'], "Invalid OperationLine");    }
  }

parseOperation() {
    // Binary operator iteration (FULL IMPLEMENTATION!)
    let left;

    // Parse base expression
    switch (this.la.kind) {    case 'IDENTIFIER':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case '@':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'JS':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'UNDEFINED':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'NULL':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'BOOL':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'INFINITY':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'NAN':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case '(':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case '[':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'SUPER':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'DYNAMIC_IMPORT':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'DO_IIFE':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'THIS':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'NEW_TARGET':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'IMPORT_META':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'PARAM_START':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case '->':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case '=>':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case '{':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'NUMBER':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'STRING':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'STRING_START':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'REGEX':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'REGEX_START':
      {
      const $$1 = this.parseValue();
      left = $$1;;
      break;
      }
    case 'UNARY':
      {
      const $$1 = this._match('UNARY');
      const $$2 = this.parseValue();
      left = [$$1, $$2];;
      break;
      }
    case 'DO':
      {
      const $$1 = this._match('DO');
      const $$2 = this.parseValue();
      left = ["do-iife", $$2];;
      break;
      }
    case 'UNARY_MATH':
      {
      const $$1 = this._match('UNARY_MATH');
      const $$2 = this.parseValue();
      left = [$$1, $$2];;
      break;
      }
    case '-':
      {
      const $$1 = this._match('-');
      const $$2 = this.parseValue();
      left = ["-", $$2];;
      break;
      }
    case '+':
      {
      const $$1 = this._match('+');
      const $$2 = this.parseValue();
      left = ["+", $$2];;
      break;
      }
    case 'AWAIT':
      {
      const $$1 = this._match('AWAIT');
      // Check if next token is another unary operator
      let $$2;
      if (this.la.kind === 'UNARY' || this.la.kind === 'UNARY_MATH' || this.la.kind === '-' || this.la.kind === '+') {
        const unaryOp = this._match(this.la.kind);
        const unaryArg = this.parseValue();
        $$2 = [unaryOp === '-' || unaryOp === '+' ? unaryOp : unaryOp, unaryArg];
      } else {
        $$2 = this.parseValue();
      }
      left = ["await", $$2];
      break;
      }
    case '--':
      {
      const $$1 = this._match('--');
      const $$2 = this.parseSimpleAssignable();
      left = ["--", $$2, false];;
      break;
      }
    case '++':
      {
      const $$1 = this._match('++');
      const $$2 = this.parseSimpleAssignable();
      left = ["++", $$2, false];;
      break;
      }default:
  this._error([], "Invalid Operation");
    }

    // Iterate through binary operators
    while (true) {
      switch (this.la.kind) {      case '=': {
        this._match('=');
        const right = this.parseExpression();
        const [$$1, $$2, $$3] = [left, '=', right];
        left = ["=", left, right];
        break;
      }
      case '+': {
        this._match('+');
        let right;
        if (this.la.kind === 'UNARY' || this.la.kind === 'UNARY_MATH' || this.la.kind === '-' || this.la.kind === '+' || this.la.kind === 'AWAIT') {
          const unaryOp = this._match(this.la.kind);
          const unaryArg = this.parseValue();
          right = [unaryOp === '-' || unaryOp === '+' ? unaryOp : unaryOp, unaryArg];
        } else {
          right = this.parseValue();
        }
        const [$$1, $$2, $$3] = [left, '+', right];
        left = ["+", left, right];
        break;
      }
      case '-': {
        this._match('-');
        let right;
        if (this.la.kind === 'UNARY' || this.la.kind === 'UNARY_MATH' || this.la.kind === '-' || this.la.kind === '+' || this.la.kind === 'AWAIT') {
          const unaryOp = this._match(this.la.kind);
          const unaryArg = this.parseValue();
          right = [unaryOp === '-' || unaryOp === '+' ? unaryOp : unaryOp, unaryArg];
        } else {
          right = this.parseValue();
        }
        const [$$1, $$2, $$3] = [left, '-', right];
        left = ["-", left, right];
        break;
      }
      case 'MATH': {
        const op = this._match('MATH');
        let right;
        if (this.la.kind === 'UNARY' || this.la.kind === 'UNARY_MATH' || this.la.kind === '-' || this.la.kind === '+' || this.la.kind === 'AWAIT') {
          const unaryOp = this._match(this.la.kind);
          const unaryArg = this.parseValue();
          right = [unaryOp === '-' || unaryOp === '+' ? unaryOp : unaryOp, unaryArg];
        } else {
          right = this.parseValue();
        }
        const [$$1, $$2, $$3] = [left, op, right];
        left = [op, left, right];
        break;
      }
      case '**': {
        this._match('**');
        let right;
        if (this.la.kind === 'UNARY' || this.la.kind === 'UNARY_MATH' || this.la.kind === '-' || this.la.kind === '+' || this.la.kind === 'AWAIT') {
          const unaryOp = this._match(this.la.kind);
          const unaryArg = this.parseValue();
          right = [unaryOp === '-' || unaryOp === '+' ? unaryOp : unaryOp, unaryArg];
        } else {
          right = this.parseValue();
        }
        const [$$1, $$2, $$3] = [left, '**', right];
        left = ["**", left, right];
        break;
      }
      case 'SHIFT': {
        const op = this._match('SHIFT');
        let right;
        if (this.la.kind === 'UNARY' || this.la.kind === 'UNARY_MATH' || this.la.kind === '-' || this.la.kind === '+' || this.la.kind === 'AWAIT') {
          const unaryOp = this._match(this.la.kind);
          const unaryArg = this.parseValue();
          right = [unaryOp === '-' || unaryOp === '+' ? unaryOp : unaryOp, unaryArg];
        } else {
          right = this.parseValue();
        }
        const [$$1, $$2, $$3] = [left, op, right];
        left = [op, left, right];
        break;
      }
      case 'COMPARE': {
        const op = this._match('COMPARE');
        let right;
        if (this.la.kind === 'UNARY' || this.la.kind === 'UNARY_MATH' || this.la.kind === '-' || this.la.kind === '+' || this.la.kind === 'AWAIT') {
          const unaryOp = this._match(this.la.kind);
          const unaryArg = this.parseValue();
          right = [unaryOp === '-' || unaryOp === '+' ? unaryOp : unaryOp, unaryArg];
        } else {
          right = this.parseValue();
        }
        const [$$1, $$2, $$3] = [left, op, right];
        left = [op, left, right];
        break;
      }
      case '&': {
        this._match('&');
        let right;
        if (this.la.kind === 'UNARY' || this.la.kind === 'UNARY_MATH' || this.la.kind === '-' || this.la.kind === '+' || this.la.kind === 'AWAIT') {
          const unaryOp = this._match(this.la.kind);
          const unaryArg = this.parseValue();
          right = [unaryOp === '-' || unaryOp === '+' ? unaryOp : unaryOp, unaryArg];
        } else {
          right = this.parseValue();
        }
        const [$$1, $$2, $$3] = [left, '&', right];
        left = ["&", left, right];
        break;
      }
      case '^': {
        this._match('^');
        let right;
        if (this.la.kind === 'UNARY' || this.la.kind === 'UNARY_MATH' || this.la.kind === '-' || this.la.kind === '+' || this.la.kind === 'AWAIT') {
          const unaryOp = this._match(this.la.kind);
          const unaryArg = this.parseValue();
          right = [unaryOp === '-' || unaryOp === '+' ? unaryOp : unaryOp, unaryArg];
        } else {
          right = this.parseValue();
        }
        const [$$1, $$2, $$3] = [left, '^', right];
        left = ["^", left, right];
        break;
      }
      case '|': {
        this._match('|');
        let right;
        if (this.la.kind === 'UNARY' || this.la.kind === 'UNARY_MATH' || this.la.kind === '-' || this.la.kind === '+' || this.la.kind === 'AWAIT') {
          const unaryOp = this._match(this.la.kind);
          const unaryArg = this.parseValue();
          right = [unaryOp === '-' || unaryOp === '+' ? unaryOp : unaryOp, unaryArg];
        } else {
          right = this.parseValue();
        }
        const [$$1, $$2, $$3] = [left, '|', right];
        left = ["|", left, right];
        break;
      }
      case '&&': {
        this._match('&&');
        let right;
        if (this.la.kind === 'THROW') {
          // Parse throw as expression
          right = this.parseThrow();
        } else if (this.la.kind === 'UNARY' || this.la.kind === 'UNARY_MATH' || this.la.kind === '-' || this.la.kind === '+' || this.la.kind === 'AWAIT') {
          // Parse unary operation
          const unaryOp = this._match(this.la.kind);
          const unaryArg = this.parseValue();
          right = [unaryOp === '-' || unaryOp === '+' ? unaryOp : unaryOp, unaryArg];
        } else {
          right = this.parseValue();
          // Check for higher-precedence binary operators after the value
          // (comparison, bitwise, arithmetic - all higher than && ||)
          if (this.la.kind === 'COMPARE' || this.la.kind === 'RELATION' || this.la.kind === '&' || this.la.kind === '^' || this.la.kind === '|' || this.la.kind === '+' || this.la.kind === '-' || this.la.kind === 'MATH' || this.la.kind === '**' || this.la.kind === 'SHIFT') {
            const binOp = this.la.kind === 'COMPARE' || this.la.kind === 'RELATION' || this.la.kind === 'MATH' || this.la.kind === 'SHIFT' ? this._match(this.la.kind) : this._match(this.la.kind);
            const binRight = this.parseValue();
            right = [binOp, right, binRight];
          }
        }
        const [$$1, $$2, $$3] = [left, '&&', right];
        left = ["&&", left, right];
        break;
      }
      case '||': {
        this._match('||');
        let right;
        if (this.la.kind === 'THROW') {
          // Parse throw as expression
          right = this.parseThrow();
        } else if (this.la.kind === 'UNARY' || this.la.kind === 'UNARY_MATH' || this.la.kind === '-' || this.la.kind === '+' || this.la.kind === 'AWAIT') {
          // Parse unary operation
          const unaryOp = this._match(this.la.kind);
          const unaryArg = this.parseValue();
          right = [unaryOp === '-' || unaryOp === '+' ? unaryOp : unaryOp, unaryArg];
        } else {
          right = this.parseValue();
          // Check for higher-precedence binary operators after the value
          // (comparison, bitwise, arithmetic - all higher than && ||)
          if (this.la.kind === 'COMPARE' || this.la.kind === 'RELATION' || this.la.kind === '&' || this.la.kind === '^' || this.la.kind === '|' || this.la.kind === '+' || this.la.kind === '-' || this.la.kind === 'MATH' || this.la.kind === '**' || this.la.kind === 'SHIFT') {
            const binOp = this.la.kind === 'COMPARE' || this.la.kind === 'RELATION' || this.la.kind === 'MATH' || this.la.kind === 'SHIFT' ? this._match(this.la.kind) : this._match(this.la.kind);
            const binRight = this.parseValue();
            right = [binOp, right, binRight];
          }
        }
        const [$$1, $$2, $$3] = [left, '||', right];
        left = ["||", left, right];
        break;
      }
      case '??': {
        this._match('??');
        let right;
        if (this.la.kind === 'UNARY' || this.la.kind === 'UNARY_MATH' || this.la.kind === '-' || this.la.kind === '+' || this.la.kind === 'AWAIT') {
          const unaryOp = this._match(this.la.kind);
          const unaryArg = this.parseValue();
          right = [unaryOp === '-' || unaryOp === '+' ? unaryOp : unaryOp, unaryArg];
        } else {
          right = this.parseValue();
        }
        const [$$1, $$2, $$3] = [left, '??', right];
        left = ["??", left, right];
        break;
      }
      case '!?': {
        this._match('!?');
        let right;
        if (this.la.kind === 'UNARY' || this.la.kind === 'UNARY_MATH' || this.la.kind === '-' || this.la.kind === '+' || this.la.kind === 'AWAIT') {
          const unaryOp = this._match(this.la.kind);
          const unaryArg = this.parseValue();
          right = [unaryOp === '-' || unaryOp === '+' ? unaryOp : unaryOp, unaryArg];
        } else {
          right = this.parseValue();
        }
        const [$$1, $$2, $$3] = [left, '!?', right];
        left = ["!?", left, right];
        break;
      }
      case 'RELATION': {
        const op = this._match('RELATION');
        let right;
        if (this.la.kind === 'UNARY' || this.la.kind === 'UNARY_MATH' || this.la.kind === '-' || this.la.kind === '+' || this.la.kind === 'AWAIT') {
          const unaryOp = this._match(this.la.kind);
          const unaryArg = this.parseValue();
          right = [unaryOp === '-' || unaryOp === '+' ? unaryOp : unaryOp, unaryArg];
        } else {
          right = this.parseValue();
        }
        const [$$1, $$2, $$3] = [left, op, right];
        left = [op, left, right];
        break;
      }
      case 'POST_IF': {
        this._match('POST_IF');
        const right = this.parseOperation();
        const [$$1, $$2, $$3] = [left, 'POST_IF', right];
        left = ["if", right, [left]];
        break;
      }
      case 'POST_UNLESS': {
        this._match('POST_UNLESS');
        const right = this.parseOperation();
        const [$$1, $$2, $$3] = [left, 'POST_UNLESS', right];
        left = ["unless", right, [left]];
        break;
      }
      case 'COMPOUND_ASSIGN': {
        const op = this._match('COMPOUND_ASSIGN');
        const right = this.parseExpression();
        const [$$1, $$2, $$3] = [left, op, right];
        left = [op, left, right];
        break;
      }
      case '--': {
        this._match('--');
        const [$$1, $$2] = [left, '--'];
        left = ["--", left, true];
        break;
      }
      case '++': {
        this._match('++');
        const [$$1, $$2] = [left, '++'];
        left = ["++", left, true];
        break;
      }
      case '?': {
        this._match('?');
        const [$$1, $$2] = [left, '?'];
        left = ["?", left];
        break;
      }        case 'SPACE?': {
          // Ternary operator: condition ? trueBranch : falseBranch
          // Branches can contain operators, so use parseOperation
          this._match('SPACE?');
          const trueBranch = this.parseOperation();
          this._match(':');
          const falseBranch = this.parseOperation();
          left = ["?:", left, trueBranch, falseBranch];
          break;
        }
        case 'FOR': {
          // Comprehension: Expression FOR ForVariables FORIN/FOROF/FORFROM Expression ...
          this._match('FOR');

          // Check for AWAIT (for-from)
          let isAsync = false;
          if (this.la.kind === 'AWAIT') {
            this._match('AWAIT');
            isAsync = true;
          }

          // Check for OWN (for-of)
          let isOwn = false;
          if (this.la.kind === 'OWN') {
            this._match('OWN');
            isOwn = true;
          }

          // Parse variables
          const vars = this.parseForVariables();

          // Determine loop type
          let loopType;
          if (this.la.kind === 'FORIN') {
            this._match('FORIN');
            loopType = 'for-in';
          } else if (this.la.kind === 'FOROF') {
            this._match('FOROF');
            loopType = 'for-of';
          } else if (this.la.kind === 'FORFROM') {
            this._match('FORFROM');
            loopType = 'for-from';
          } else {
            this._error(['FORIN', 'FOROF', 'FORFROM'], "Expected for loop type");
          }

          // Parse iterable
          const iterable = this.parseValue();  // Use Value to avoid cycles

          // Parse optional BY (step)
          let step = null;
          if (this.la.kind === 'BY') {
            this._match('BY');
            step = this.parseValue();
          }

          // Parse optional WHEN (guard)
          let guard = null;
          if (this.la.kind === 'WHEN') {
            this._match('WHEN');
            // Parse guard - use parseOperation to handle complex expressions
            // (x > 1 && x < 4, !isEmpty, etc.)
            guard = this.parseOperation();
          }

          // Build loop spec based on type
          let loopSpec;
          if (loopType === 'for-in') {
            loopSpec = [loopType, vars, iterable, step];
          } else if (loopType === 'for-of') {
            loopSpec = [loopType, vars, iterable, isOwn];
          } else {
            loopSpec = [loopType, vars, iterable, isAsync, null];
          }

          // Build comprehension
          // NOTE: 'left' at this point is the full expression including any operators
          // e.g., for "sum += i for i in arr", left is already ["+=" "sum" "i"]
          const guards = guard ? [guard] : [];
          left = ["comprehension", left, [loopSpec], guards];
          return left;  // Comprehensions end the operation chain
        }
        default:
          return left;
      }
    }
  }

parseDoIife() {const $$1 = this._match('DO_IIFE');
      const $$2 = this.parseCode();
      return ["do-iife", $$2];  }

parse$accept() {const $$1 = this.parseRoot();
      const $$2 = this._match('$end');
      return [$$1, $$2];  }}

const parser = new Parser();

export { parser, Parser };
export const parse = parser.parse.bind(parser);
export default parser;